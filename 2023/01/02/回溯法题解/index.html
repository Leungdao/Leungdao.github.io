

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="荔枝">
  <meta name="keywords" content="">
  
    <meta name="description" content="《算法设计与分析》一书中回溯法习题求解">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯法题解">
<meta property="og:url" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="荔枝的博客">
<meta property="og:description" content="《算法设计与分析》一书中回溯法习题求解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102174153224.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102221034796.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214448956.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214508262.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214546946.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214609533.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102223036593.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102223107634.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103104730475.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103102814230.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103102521881.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103110515293.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103210648180.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103200657123.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103211224034.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103214009258.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104104042126.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103214343137.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104102358652.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104103946623.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104103710037.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104111844462.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104112758039.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104113608782.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104113717884.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230108094031142.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230108094127364.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104115831309.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105102915399.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105111327567.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105113429567.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105113714306.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105194002403.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105194603562.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114234838.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114335314.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115004711.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114937912.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114617529.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091616647.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091745691.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091753460.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114815154.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106111415596.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115631677.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115723106.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106212553925.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115824426.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115900644.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115926418.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106220815943.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120010640.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120024040.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106230008395.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106231319219.png">
<meta property="og:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120329010.png">
<meta property="article:published_time" content="2023-01-02T09:36:20.000Z">
<meta property="article:modified_time" content="2023-01-08T12:52:52.385Z">
<meta property="article:author" content="荔枝">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leungto.github.io/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102174153224.png">
  
  
  
  <title>回溯法题解 - 荔枝的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leungto.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="回溯法题解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-02 17:36" pubdate>
          2023年1月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          146 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">回溯法题解</h1>
            
            
              <div class="markdown-body">
                
                <p>《算法设计与分析》一书中回溯法习题求解</p>
<span id="more"></span>
<p>书写结构：解空间和解结构，剪枝策略，示例，代码，时间复杂度分析</p>
<h1 id="5-1子集和问题"><a href="#5-1子集和问题" class="headerlink" title="5-1子集和问题"></a>5-1子集和问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102174153224.png" srcset="/img/loading.gif" lazyload alt="image-20230102174153224" style="zoom: 67%;"></p>
<h3 id="1-解空间和解结构"><a href="#1-解空间和解结构" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>类似于0-1背包问题，对于S大小为n的子集和问题，解空间是由长度为n的0-1向量组成，解的结构为子集树，如对于上述示例的解，解空间即为(1,1,1,0,0,0)</p>
<h3 id="2-剪枝策略"><a href="#2-剪枝策略" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>注意到题目说S是正整数的集合，c是正整数，故深搜的过程一定使得子集和增加或不变。</p>
<p>考虑在某节点处向下搜索的过程，设当前层数为k（即当前考虑是否加入数S[k]到子集中）</p>
<p>约束函数：维护变量cw表示当前子集和，若<code>cw+S[k]&gt;c</code>，则剪去左子树</p>
<p>限界函数：计算变量rw表示剩余的整数之和(S[k+1:n-1]之和)，若<code>cw+rw&lt;c</code>，即将之后所有整数加入子集也无法得到解，故减去右子树</p>
<p>对于本题而言，如果只要一个可行解的话，可以在搜索每个节点的时候，在考虑完是否加入数S[k]之后，判断S[k]是否等于c，若等于，则无需再搜索了</p>
<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>太多了不太好画，减少点数据量：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102221034796.png" srcset="/img/loading.gif" lazyload alt="image-20230102221034796" style="zoom: 50%;"></p>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>这里就没弄文件读写了（可以直接粘贴下面的输入测试啦）</p>
<p>输入1：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>输入2：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>得到一个解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> S[N],res[N];<br><span class="hljs-type">int</span> n,c;<br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//解的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispsolution</span><span class="hljs-params">(<span class="hljs-type">int</span> res[])</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;第&quot;</span>&lt;&lt;num++&lt;&lt;<span class="hljs-string">&quot;个解&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>     <span class="hljs-keyword">if</span>(res[i]) cout&lt;&lt;S[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cw,<span class="hljs-type">int</span> rw,<span class="hljs-type">int</span> res[],<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(level&gt;n)<span class="hljs-comment">//到达叶节点了</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(cw==c)<span class="hljs-comment">//找到可行解</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            &#123;<br>             <span class="hljs-keyword">if</span>(res[i]) cout&lt;&lt;S[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//直接结束程序(会不会有点暴力)</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(cw+S[level]&lt;=c)<span class="hljs-comment">//考虑是否进入左子树</span><br>        &#123;<br>            res[level]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(cw+S[level],rw-S[level],res,level+<span class="hljs-number">1</span>);<br>        &#125;<br>        rw=rw-S[level];<span class="hljs-comment">//计算剩余整数之和(剩余整数不包括当前整数)</span><br>        <span class="hljs-comment">//这里和博客不太一样(他rw算的是包括当前的整数的)</span><br>        <span class="hljs-keyword">if</span>(cw+rw&gt;=c)<span class="hljs-comment">//考虑是否进入右子树</span><br>        &#123;<br>            res[level]=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs</span>(cw,rw,res,level+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-type">int</span> rw=<span class="hljs-number">0</span>;<span class="hljs-comment">//为了方便计算rw,首先计算所有整数的和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//为了方便,从下标1开始</span><br>    &#123;<br>        cin&gt;&gt;S[i];<br>        rw=rw+S[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,rw,res,<span class="hljs-number">1</span>);<span class="hljs-comment">//cw=1,res存储解,从第一层开始</span><br>    <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;No Solution!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214448956.png" srcset="/img/loading.gif" lazyload alt="image-20230102214448956"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214508262.png" srcset="/img/loading.gif" lazyload alt="image-20230102214508262"></p>
<p>得到所有解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> S[N],res[N];<br><span class="hljs-type">int</span> n,c;<br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//解的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispsolution</span><span class="hljs-params">(<span class="hljs-type">int</span> res[])</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;第&quot;</span>&lt;&lt;num++&lt;&lt;<span class="hljs-string">&quot;个解&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>     <span class="hljs-keyword">if</span>(res[i]) cout&lt;&lt;S[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cw,<span class="hljs-type">int</span> rw,<span class="hljs-type">int</span> res[],<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(level&gt;n)<span class="hljs-comment">//到达叶节点了</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(cw==c)  <span class="hljs-built_in">dispsolution</span>(res);<span class="hljs-comment">//找到可行解</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(cw+S[level]&lt;=c)<span class="hljs-comment">//考虑是否进入左子树</span><br>        &#123;<br>            res[level]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(cw+S[level],rw-S[level],res,level+<span class="hljs-number">1</span>);<br>        &#125;<br>        rw=rw-S[level];<span class="hljs-comment">//计算剩余整数之和(剩余整数不包括当前整数)</span><br>        <span class="hljs-comment">//这里和博客不太一样(他rw算的是包括当前的整数的)</span><br>        <span class="hljs-keyword">if</span>(cw+rw&gt;=c)<span class="hljs-comment">//考虑是否进入右子树</span><br>        &#123;<br>            res[level]=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs</span>(cw,rw,res,level+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-type">int</span> rw=<span class="hljs-number">0</span>;<span class="hljs-comment">//为了方便计算rw,首先计算所有整数的和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//为了方便,从下标1开始</span><br>    &#123;<br>        cin&gt;&gt;S[i];<br>        rw=rw+S[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,rw,res,<span class="hljs-number">1</span>);<span class="hljs-comment">//cw=1,res存储解,从第一层开始</span><br>    <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;No Solution!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214546946.png" srcset="/img/loading.gif" lazyload alt="image-20230102214546946"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102214609533.png" srcset="/img/loading.gif" lazyload alt="image-20230102214609533"></p>
<h3 id="5-时间复杂度分析"><a href="#5-时间复杂度分析" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h3><p>考虑最坏情况下时间复杂度，每个节点都进行搜索，处理每个节点所需的时间均为$O(1)$，一共有1+2+4+8+…+2^n^</p>
<p>=$O(2^{n+1})$个节点，故时间复杂度为$O(2^{n+1})$</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gl620321/article/details/108801724">https://blog.csdn.net/gl620321/article/details/108801724</a></p>
<h1 id="5-2-最小长度电路板排列问题"><a href="#5-2-最小长度电路板排列问题" class="headerlink" title="5-2 最小长度电路板排列问题"></a>5-2 最小长度电路板排列问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102223036593.png" srcset="/img/loading.gif" lazyload alt="image-20230102223036593" style="zoom:67%;"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230102223107634.png" srcset="/img/loading.gif" lazyload alt="image-20230102223107634" style="zoom:67%;"></p>
<h3 id="1-解空间和解结构-1"><a href="#1-解空间和解结构-1" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>类似于旅行商问题，对于n个电路板的最小电路板排列问题，其解空间为n个数的全排列，解结构为排列树</p>
<h3 id="2-剪枝策略-1"><a href="#2-剪枝策略-1" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护变量bestd表示当前的最小长度，假设此时选择第i个位置上的电路板，考虑选择第j个电路板(j&gt;=i，因为i前面的已经选择好了)作为该位置上的排列，此时利用已经选择好的第1~第i个位置上的电路板（第i个位置刚刚选择好的）来计算连接块的最大长度，若该长度小于当前最优解，则继续进行下面位置的选择，否则第i个位置上不能选择第j个电路板，剪去该子树</p>
<h3 id="3-示例-1"><a href="#3-示例-1" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>示例数据量太大，减少点</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>4个电路板，L1={1,2},L2={1,2,4},L3={1,4},L4={1,2,3}</p>
<p>类似于下面的画法（排列树太多了，只画了一个子树）：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103104730475.png" srcset="/img/loading.gif" lazyload alt="image-20230103104730475"></p>
<p>最后的结果：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103102814230.png" srcset="/img/loading.gif" lazyload alt="image-20230103102814230"></p>
<h3 id="4-代码-1"><a href="#4-代码-1" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>输入文件 input.txt:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>输入含义</p>
<p>L1={1,4,5,6},L2={1,2,3,6,8},L3={1,3,4,5},L4={1,2,3,4,6},L5={1,7,8}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> bestx[<span class="hljs-number">10</span>];<span class="hljs-comment">// 这是最终的最优解排列顺序</span><br><span class="hljs-type">int</span> B[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-comment">//电路板在连接块中的排列，是一个二维数组</span><br><span class="hljs-type">int</span> x[<span class="hljs-number">10</span>], low[<span class="hljs-number">10</span>], high[<span class="hljs-number">10</span>];<span class="hljs-comment">// 分别是当前的排列、最左边电路板、最右边电路板</span><br><span class="hljs-type">int</span> bestd=<span class="hljs-number">0</span>;<span class="hljs-comment">// 最优解</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">int</span> ii)</span> </span>&#123;<span class="hljs-comment">// 计算当前ii排列最小长度</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>		high[i] = <span class="hljs-number">0</span>;<br>		low[i] = n + <span class="hljs-number">1</span>;<span class="hljs-comment">// 先初始化最左边和最右边的值，</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= ii; i++)<span class="hljs-comment">// 对于第i行</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k++)<span class="hljs-comment">// k列</span><br>			<span class="hljs-keyword">if</span> (B[x[i]][k] &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 如果第i个电路板在第k个连接块中，</span><br>				<span class="hljs-keyword">if</span> (i &lt; low[k])<span class="hljs-comment">//low[k]代表第K个连接块的最左边的值，如果i比它小，则更新左值</span><br>					low[k] = i;<br>				<span class="hljs-keyword">if</span> (i &gt; high[k])<br>					high[k] = i;<span class="hljs-comment">//如果比初始的右值大，则更新右值</span><br>			&#125;<br>	<span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k++)<br>		<span class="hljs-keyword">if</span> (low[k] &lt;= n &amp;&amp; high[k] &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; high[k] - low[k])<br>            <span class="hljs-comment">//若连接块的长度无法得到（前面两个bool表达式不满足，不计算该连接块的长度）</span><br>			tmp = high[k] - low[k];<span class="hljs-comment">//计算每个连接块的举例</span><br>	<span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* x, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<span class="hljs-comment">// 交换i和j位置的值</span><br>	<span class="hljs-type">int</span> tmp;<br>	tmp = x[i];<br>	x[i] = x[j];<br>	x[j] = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (i == n) &#123;<span class="hljs-comment">// 如果到达末尾</span><br>		<span class="hljs-type">int</span> tmp = <span class="hljs-built_in">len</span>(i);<span class="hljs-comment">// 计算当前排列最小长度</span><br>		<span class="hljs-keyword">if</span> (tmp &lt; bestd) &#123;<br>			bestd = tmp;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>				bestx[j] = x[j];<br>		&#125; <span class="hljs-comment">// 如果比最优解还要好，则更新bestx[]排列；</span><br>	&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 若不是末尾；</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++) &#123;<br>			<span class="hljs-built_in">swap</span>(x, i, j);<br>			<span class="hljs-type">int</span> ld = <span class="hljs-built_in">len</span>(i);<br>			<span class="hljs-keyword">if</span> (ld &lt; bestd)<br>				<span class="hljs-built_in">backtrack</span>(i + <span class="hljs-number">1</span>);<span class="hljs-comment">// 则继续进入下一个数，</span><br>			<span class="hljs-built_in">swap</span>(x, i, j);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arrangeBoards</span><span class="hljs-params">()</span> </span>&#123;<br>	bestd = n + <span class="hljs-number">1</span>;<span class="hljs-comment">// 先假设一个很大的值</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		x[i] = i;<span class="hljs-comment">// 这里是最开始的排序；</span><br>	<span class="hljs-built_in">backtrack</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> bestd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>;<span class="hljs-comment">//文件输入流</span><br>	ifs&gt;&gt;n;<br>	ifs&gt;&gt;m;<br><br>	<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(m)</span></span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>			ifs&gt;&gt;B[i][j] ;<span class="hljs-comment">// 输入的电路板的二维数组排列</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-type">int</span> minLen = <span class="hljs-built_in">arrangeBoards</span>();<br>	cout&lt;&lt;minLen&lt;&lt;endl;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		cout&lt;&lt;bestx[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>	ifs.<span class="hljs-built_in">close</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103102521881.png" srcset="/img/loading.gif" lazyload alt="image-20230103102521881"></p>
<h3 id="5-时间复杂度分析-1"><a href="#5-时间复杂度分析-1" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h3><p>对于最坏情况，每个节点都需要计算一次len，即序号运行len函数，而第i层节点运行len函数时间复杂度为$O(im)$，故最坏情况下所需时间为$T=O(m)<em>(n-1)+O(2m)</em>(n-1)<em>(n-2)+…+O(n</em>m)<em>(n-1)!$，故最坏情况下时间复杂度为$O(m</em>n!)$</p>
<h1 id="5-3-最小重量机器设计问题"><a href="#5-3-最小重量机器设计问题" class="headerlink" title="5-3 最小重量机器设计问题"></a>5-3 最小重量机器设计问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103110515293.png" srcset="/img/loading.gif" lazyload alt="image-20230103110515293" style="zoom:67%;"></p>
<p>题目两个要求，总价格不超过d，并且部件重量之和要最小</p>
<h3 id="1-解空间和解结构-2"><a href="#1-解空间和解结构-2" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个部件，m个供应商的最小重量机器设计问题，其解空间为长度为n的向量，向量的每一项为1~m的整数，对应的解结构为排列树（也不是那种TSP的排列树，不过也是排列啦，姑且称之为排列树）</p>
<h3 id="2-剪枝策略-2"><a href="#2-剪枝策略-2" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>考虑第i个部件供应商的选择</p>
<p>约束函数：维护变量cp表示当前已经购得的部件的价格之和，假设考虑选择第j个供应商，若<code>cp+c[i][j]&gt;d</code>，则剪去以该节点为根节点的子树，无需再进行搜索</p>
<p>限界函数：维护变量cw表示当前已经购得的部件的重量之和，变量bestw表示当前最优解的重量之和，假设考虑选择第j个供应商，若<code>cw+w[i][j]&gt;=bestw</code>，则剪去该节点为根节点的子树，无需进行搜索</p>
<h3 id="3-示例-2"><a href="#3-示例-2" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>对于题中示例画树：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103210648180.png" srcset="/img/loading.gif" lazyload alt="image-20230103210648180"></p>
<h3 id="4-代码-2"><a href="#4-代码-2" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>输入：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>没实现文件读写了~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,d;<span class="hljs-comment">//n个部件，m个供应商，总价格不超过d</span><br><span class="hljs-type">int</span> c[<span class="hljs-number">999</span>][<span class="hljs-number">999</span>];<span class="hljs-comment">//c[i][j]为从供应商j购买部件i所花费的价格；</span><br><span class="hljs-type">int</span> w[<span class="hljs-number">999</span>][<span class="hljs-number">999</span>];<span class="hljs-comment">//w[i][j]为......重量</span><br><span class="hljs-type">int</span> cw=<span class="hljs-number">0</span>,cp=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前部件的重量 价格</span><br><span class="hljs-type">int</span> bestw=<span class="hljs-number">999</span>,bestp=<span class="hljs-number">999</span>;<span class="hljs-comment">//最优方案的重量，价格</span><br><span class="hljs-type">int</span> x[<span class="hljs-number">999</span>];<span class="hljs-comment">//当前部件i从供应商j购买</span><br><span class="hljs-type">int</span> bestx[<span class="hljs-number">999</span>];<span class="hljs-comment">//最优方案部件i从哪个供应商买</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(i&gt;=n)&#123;<span class="hljs-comment">//到达最后一层 </span><br>		<span class="hljs-keyword">if</span>(cp&lt;=d&amp;&amp;cw&lt;bestw)&#123;<span class="hljs-comment">//如果价格没超过d，并且重量小于之前方案的bestw </span><br>			bestw=cw;<span class="hljs-comment">//重量更新 </span><br>			bestp=cp;<span class="hljs-comment">//价格更新</span><br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>				bestx[k]=x[k];<span class="hljs-comment">//部件的供应商进行更新 </span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123;<br>	<span class="hljs-comment">//所有的方式都尝试了一遍，比较找到最优的重量</span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>			x[i]=j;<span class="hljs-comment">//当前部件i的供应商为j</span><br>			cw=cw+w[i][j];<br>			cp=cp+c[i][j];<br>			<span class="hljs-keyword">if</span>(cw&lt;bestw&amp;&amp;cp&lt;=d)<span class="hljs-comment">//如果这次的选择要比之前方案的更优 </span><br>			<span class="hljs-built_in">backtrack</span>(i+<span class="hljs-number">1</span>); <br>		<span class="hljs-comment">//回溯</span><br>			cw-=w[i][j];<br>			cp-=c[i][j]; <br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;<span class="hljs-comment">//n个部件，m个供应商，总价格不超过d</span><br>	<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>			cin&gt;&gt;c[i][j];<span class="hljs-comment">//c[i][j]为从供应商j购买部件i所花费的价格；</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>			cin&gt;&gt;w[i][j];<span class="hljs-comment">//w[i][j]为......重量</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//第i个部件</span><br>	cout&lt;&lt;bestw&lt;&lt;endl;<span class="hljs-comment">//最优方案的重量</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>	cout&lt;&lt;bestx[k]+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//因为j从0开始，所以输出的时候加一个1；</span><br><br>&#125; <br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103200657123.png" srcset="/img/loading.gif" lazyload alt="image-20230103200657123"></p>
<h3 id="5-时间复杂度分析-2"><a href="#5-时间复杂度分析-2" class="headerlink" title="5. 时间复杂度分析"></a>5. 时间复杂度分析</h3><p>考虑最坏情况，对于每个非叶子节点，搜索所需时间为$O(m)$，对于每个叶子节点，搜索所需的时间为$O(1)$，故最坏情况下所需时间为$T=m*(m+m^2+…+m^{n-1})+m^n=O(m^n)$</p>
<h1 id="5-4-运动员最佳配对问题"><a href="#5-4-运动员最佳配对问题" class="headerlink" title="5-4 运动员最佳配对问题"></a>5-4 运动员最佳配对问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103211224034.png" srcset="/img/loading.gif" lazyload alt="image-20230103211224034" style="zoom:67%;"></p>
<p>输入：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">52<br></code></pre></td></tr></table></figure>
<h3 id="1-解空间和解结构-3"><a href="#1-解空间和解结构-3" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>将问题转换为男运动员选女运动员的问题，故n个男、女运动员的运动员最佳匹配问题的解空间为n个数的全排列，对应的解结构为排列树</p>
<h3 id="2-剪枝策略-3"><a href="#2-剪枝策略-3" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>考虑对第i个男运动员匹配女运动员的情况，其中变量Max存储当前最优解的竞赛优势，变量sum存储第1~i-1个已经匹配完成的男运动员的竞赛优势，计算第i~n个男运动员的最大可能的竞赛优势ctn，若<code>cnt+sum&lt;Max</code>，则剪去该节点及其子树</p>
<p>其中第j个男运动员的最大可能的竞赛优势为该男运动员与所有女运动员进行匹配所得竞赛优势中最大者，存储到maxsum数组中</p>
<h3 id="3-示例-3"><a href="#3-示例-3" class="headerlink" title="3.示例"></a>3.示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103214009258.png" srcset="/img/loading.gif" lazyload alt="image-20230103214009258"></p>
<h3 id="4-代码-3"><a href="#4-代码-3" class="headerlink" title="4.代码"></a>4.代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> boy[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>],girl[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>];   <span class="hljs-comment">//分别用于存放男、女运动员的竞赛优势</span><br><span class="hljs-type">int</span> Max=INT_MIN;   <span class="hljs-comment">//Max代表男女双方竞赛优势的总和的最大值</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;   <span class="hljs-comment">//sum为临时求和</span><br><span class="hljs-type">int</span> data[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>];   <span class="hljs-comment">//data[i][]用于存放男运动员 i 配对后的双方竞赛优势</span><br><span class="hljs-type">int</span> maxSum[<span class="hljs-number">21</span>];   <span class="hljs-comment">//记录每个男生匹配后可达到的最大双方竞赛优势</span><br><span class="hljs-type">int</span> book[<span class="hljs-number">21</span>];   <span class="hljs-comment">//用于标记女运动员是否已匹配：book[0]未匹配；book[1]匹配</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t&gt;=n)   <span class="hljs-comment">//t到达n之后，代表全部标记访问了,得到了最大值</span><br>    &#123;<br>        Max=<span class="hljs-built_in">max</span>(Max,sum);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> ctn=<span class="hljs-number">0</span>;   <br><span class="hljs-comment">//剪枝函数:之前t个已匹配好的男女运动员的sum与之后的 t-&gt;n-1 个男匹配女的最大值加起来与已经得到的Max比较，若前者&lt;=Max，剪枝</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t;i&lt;n;i++)   <span class="hljs-comment">//求t及t之后男生匹配女生的最大值的和</span><br>        ctn+=maxSum[i];<br><span class="hljs-comment">//若从第t组-&gt;第n组，当前搜索sum加上假设匹配后的最大值cxn，仍然小于Max ，就需要剪枝了，则Max为已经求得的最大值</span><br>    <span class="hljs-keyword">if</span>(sum+ctn&lt;Max)   <br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)   <span class="hljs-comment">//若cxn&gt;=Max，要探索子树。从第t个男生开始匹配，找未匹配的女生</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!book[i])   <span class="hljs-comment">//第 i 个女生未匹配</span><br>        &#123;<br>            book[i]=<span class="hljs-number">1</span>;   <span class="hljs-comment">//第 t 个男生匹配女生i</span><br>            sum+=data[t][i];   <span class="hljs-comment">//加上男生t与女生i的男女双方竞赛优势</span><br>            <span class="hljs-built_in">dfs</span>(t+<span class="hljs-number">1</span>);   <span class="hljs-comment">//为第i+1个男生匹配</span><br>            book[i]=<span class="hljs-number">0</span>;   <span class="hljs-comment">//若第 t 个男生匹配女生i得到的sum不大于Max，则回溯</span><br>            sum-=data[t][i];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)   <span class="hljs-comment">//输入男运动员的竞赛优势</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            cin&gt;&gt;boy[i][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)   <span class="hljs-comment">//输入女运动员的竞赛优势</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            cin&gt;&gt;girl[i][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>        <span class="hljs-comment">//对每个男生都求男女双方竞赛优势，则能得到i*j种结果（涵盖了P[i][j]*Q[j][i]与Q[i][j]*P[j][i]）</span><br>            data[i][j]=boy[i][j]*girl[j][i];   <br>            maxSum[i]=<span class="hljs-built_in">max</span>(maxSum[i],data[i][j]);   <span class="hljs-comment">//记录每个男生匹配后可达到的最大双方竞赛优势，用于后面的剪枝</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    cout&lt;&lt;Max&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104104042126.png" srcset="/img/loading.gif" lazyload alt="image-20230104104042126"></p>
<h3 id="5-时间复杂度分析-3"><a href="#5-时间复杂度分析-3" class="headerlink" title="5.时间复杂度分析"></a>5.时间复杂度分析</h3><p>考虑最坏情况，每个节点都需要搜索，对于非叶子节点，其需要时间为$O(n)$，对于叶子节点，其所需时间为$O(1)$，故所需时间为$T=n<em>(n+n</em>(n-1)+…+n!)+n!=O(n*n!)$</p>
<h1 id="5-5-无分隔符字典问题"><a href="#5-5-无分隔符字典问题" class="headerlink" title="5-5 无分隔符字典问题"></a>5-5 无分隔符字典问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230103214343137.png" srcset="/img/loading.gif" lazyload alt="image-20230103214343137" style="zoom:67%;"></p>
<h3 id="1-解空间和解结构-4"><a href="#1-解空间和解结构-4" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>由S为$L_k$子集可知n个符号，长度为k的无分隔符字典问题的解空间为长度为$n^k$的向量，其中向量每一项为0或1，表示$L_k$中某一项是否在S中，解结构为子集树</p>
<h3 id="2-剪枝策略-4"><a href="#2-剪枝策略-4" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>首先将$L_k$中所有字字符串放入数组L中，考虑是否放入下标为i的字符串：</p>
<p>约束函数：若该字符串与当前S集合中的任意字符串按照题目所给方式进行拼接，结果均不在S集合中，且不为该字符串本身，则考虑将其放入，搜索其左子树，否则剪去该节点的左子树</p>
<p>限界函数：考虑不放入该字符串，若将i+1~$n^k$的字符串均放入，若n^k^-i+S.size&lt;best，则无需搜索其右子树，剪去该节点的右子树</p>
<h3 id="3-示例-4"><a href="#3-示例-4" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>假设$\sum=(a,b),L_k=\{aa,ab,ba,bb\}$,则$L_k$的一个最大无分隔符字典为$\{aa,bb\}$</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104102358652.png" srcset="/img/loading.gif" lazyload alt="image-20230104102358652"></p>
<h3 id="4-代码-4"><a href="#4-代码-4" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> *ak;<br><span class="hljs-type">int</span> lk;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> best = <span class="hljs-number">0</span>; <span class="hljs-comment">//最大无分隔符字典元素个数</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; L;  <span class="hljs-comment">//将所有的长度为k的数字字符串存到集合L中</span><br>set&lt;<span class="hljs-type">int</span>&gt; S;  <span class="hljs-comment">//当前字典中的字符串存储在集合s中</span><br><br><br><span class="hljs-comment">//将下标为L[]中下标为i的字符串存入集合s</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    S.<span class="hljs-built_in">insert</span>(L[i]);<br>&#125;<br><br><span class="hljs-comment">//将下标为L[]中下标为i的字符串存入集合s</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    S.<span class="hljs-built_in">erase</span>(L[i]);<br>&#125;<br><br><span class="hljs-comment">//将ak[]中起点为i，长度为k数字串转换为十进制数字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">digi</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;k; j++)<br>    &#123;<br>        x *= <span class="hljs-number">10</span>;<br>        x += ak[j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-comment">//判断字符串a和第b个字符串是否互不为前缀</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pref</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> bb =b;<span class="hljs-comment">//这里用bb只是因为原代码不太对,我直接改了</span><br>    <span class="hljs-type">int</span> x = a;<br>    <span class="hljs-type">int</span> y = bb/<span class="hljs-number">10</span>;<span class="hljs-comment">//去掉最后一位，得到高k-1位(因为验证的时候这位是肯定要剔除的</span><br>    <span class="hljs-comment">//按理说x也要剔除最高位，但是后面的循环不会碰到最高位，所以这里没剔除了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k<span class="hljs-number">-1</span>; i++) <span class="hljs-comment">//ak[0, k-2]存放x的低k-1位，ak[k-1, k-1 + (k-2)]存放y</span><br>    &#123;<br>        ak[k-i<span class="hljs-number">-2</span>] = x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>        ak[<span class="hljs-number">2</span>*k-i<span class="hljs-number">-3</span>] = y % <span class="hljs-number">10</span>;<br>        y /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k<span class="hljs-number">-1</span>; i++) <span class="hljs-comment">//相当于依次判断a2a3..akb1, a3a4..b1b2, akb1..bk-1是否已存在于S中，本程序中下标从0开始</span><br>        <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">digi</span>(i)) &gt; <span class="hljs-number">0</span>||<span class="hljs-built_in">digi</span>(i)==bb)  <span class="hljs-comment">//如果已存在于S中</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    x = bb;<br>    y = a/<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k<span class="hljs-number">-1</span>; i++)<span class="hljs-comment">//先放b再放a</span><br>    &#123;<br>        ak[k-i<span class="hljs-number">-2</span>] = x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>        ak[<span class="hljs-number">2</span>*k-i<span class="hljs-number">-3</span>] = y % <span class="hljs-number">10</span>;<br>        y /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;k<span class="hljs-number">-1</span>; i++)<br>        <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">count</span>(<span class="hljs-built_in">digi</span>(i)) &gt; <span class="hljs-number">0</span>||<span class="hljs-built_in">digi</span>(i)==bb)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//判断当前下标为b的字符串是否可以加入字典</span><br><span class="hljs-comment">//将字符串a1a2..ak看作k位十进制数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">oka</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> bb = L[b];<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it;  <span class="hljs-comment">//定义迭代器</span><br>    it = S.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span>(it != S.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> a = *it;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pref</span>(a, bb)) <span class="hljs-comment">//如果a,b其中一个是另一个的前缀</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        it++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//得到总元素个数为n，长度为m的全排列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Perm</span><span class="hljs-params">(<span class="hljs-type">int</span> list[], <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep&gt;m)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)<br>            x = x*<span class="hljs-number">10</span> + list[i];   <span class="hljs-comment">//转换为十进制数字</span><br>        L.<span class="hljs-built_in">push_back</span>(x);  <span class="hljs-comment">//将所有的数字字符串存到集合L中</span><br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(list[dep], list[j]);<br>            <span class="hljs-built_in">Perm</span>(list, dep+<span class="hljs-number">1</span>, m,  n);<br>            <span class="hljs-built_in">swap</span>(list[dep], list[j]);<br>        &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep &gt;= lk)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">size</span>() &gt; best)<br>            best = S.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">oka</span>(dep))<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(dep);<br>        <span class="hljs-built_in">backtrack</span>(dep+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">erase</span>(dep);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lk-dep+S.<span class="hljs-built_in">size</span>()&gt;best)<br>    <span class="hljs-built_in">backtrack</span>(dep+<span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;输入正整数n：&quot;</span>;<br>    fin &gt;&gt; n; cout &lt;&lt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入正整数k：&quot;</span>;<br>    fin &gt;&gt; k; cout &lt;&lt; k;<br>    ak = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>*k];<br>    lk = n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;k; i++) <span class="hljs-comment">//k个字符中，每一个字符都有n种选择，n^k表示所有由k个字符组成的字符串种数</span><br>        lk *= n;<br>    lk--;<br>    <span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        x[i] = i;<br>    <span class="hljs-built_in">Perm</span>(x, <span class="hljs-number">1</span>, k, n); <span class="hljs-comment">//将长度为k的全排列存入集合L中</span><br>    <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n最大无分隔符字典元素个数为：&quot;</span> &lt;&lt; best;<br><br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>    fin.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104103946623.png" srcset="/img/loading.gif" lazyload alt="image-20230104103946623"></p>
<h3 id="5-时间复杂度"><a href="#5-时间复杂度" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于n个字符，长度为k的问题，对于每个非叶子节点的左子节点，搜索需要耗费时间为$O(n^k<em>k)$，对于右子节点搜索需要的时间为$O(1)$，对于叶节点需要时间$O(1)$，故耗费的时间$T=O(2^{n^k-1}</em>n^k*k)$</p>
<h1 id="5-6-无合集问题"><a href="#5-6-无合集问题" class="headerlink" title="5-6 无合集问题"></a>5-6 无合集问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104103710037.png" srcset="/img/loading.gif" lazyload alt="image-20230104103710037" style="zoom:67%;"></p>
<p>大概的思路是从1开始每个数都尝试放入n个子集的每个子集，然后用题目给的条件x+y不属于S进行剪枝</p>
<h3 id="1-解空间和解结构-5"><a href="#1-解空间和解结构-5" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>从1开始尝试放入每个子集中，对于子集为n的无合集问题，其解空间为长度为k的向量，向量的每一项为1~n，表示对应下标的数分配到的子集，其中k为本题所求，以n=3为例，解结构如下：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104111844462.png" srcset="/img/loading.gif" lazyload alt="image-20230104111844462" style="zoom:50%;"></p>
<h3 id="2-剪枝策略-5"><a href="#2-剪枝策略-5" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>据题意，若数i无法分配到集合j(不满足和不在集合的条件)，则该节点的第j个分支无需遍历，剪去该分支</p>
<h3 id="3-示例-5"><a href="#3-示例-5" class="headerlink" title="3. 示例"></a>3. 示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104112758039.png" srcset="/img/loading.gif" lazyload alt="image-20230104112758039" style="zoom:67%;"></p>
<h3 id="4-代码-5"><a href="#4-代码-5" class="headerlink" title="4. 代码"></a>4. 代码</h3><p>定义存储当前解的数组a[N][N],其中a[n][0]表示第n个子集的元素个数a[n][1]到a[n][a[n][0]]为这个子集的所有元素。定义n。设置初始的结果ans为1(最后要减1，所以初始值其实是0)，定义最优值为best，定义最优解为e[N][N]，其中的结构和a[N][N]一样,以及定义判定数组h[N][N]，h[i][j]表示第i个子集中是否有j这个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><br><span class="hljs-type">int</span> a[N][N], n, ans = <span class="hljs-number">1</span>, best, e[N][N];<br><span class="hljs-type">bool</span> h[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;                        <span class="hljs-comment">//判断当前ans中的数是否能插入第level个子集</span><br>    <span class="hljs-keyword">if</span>(level == n)&#123;                         <span class="hljs-comment">//n个子集的下标是0到n-1,所以当level等于n时表示当前ans不能插入所有子集</span><br>        <span class="hljs-keyword">if</span>(ans &lt;= best) <span class="hljs-keyword">return</span>;             <span class="hljs-comment">//如果当前ans不如当前最优值best，就返回</span><br>        best = ans;                         <span class="hljs-comment">//如果比最优值好，更新最优值和最优解</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= a[i][<span class="hljs-number">0</span>]; j ++)<br>                e[i][j] = a[i][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;                                   <span class="hljs-comment">//判断ans能否插入第level个子集</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;           <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a[level][<span class="hljs-number">0</span>]; i ++)&#123;<span class="hljs-comment">//遍历子集</span><br>            <span class="hljs-comment">//如果ans减当前元素在子集中且这个元素不是它本身,flag就为false,表示ans不能插入这个子集</span><br>            <span class="hljs-keyword">if</span>(h[level][ans - a[level][i]] &amp;&amp; ans - a[level][i] != a[level][i]) flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-built_in">dfs</span>(level + <span class="hljs-number">1</span>);           <span class="hljs-comment">//不能插入，判断ans能不能插入第level+1个子集  </span><br>        <span class="hljs-keyword">else</span>&#123;                               <span class="hljs-comment">//可以插入，分两种情况，一种是插入，一种是不插入此子集</span><br>            <span class="hljs-comment">//插入的情况</span><br>            a[level][++ a[level][<span class="hljs-number">0</span>]] = ans; <span class="hljs-comment">//第i个子集个数加一，把元素记入子集</span><br>            h[level][ans ++] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">//把此元素标记为在此子集中</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);                         <span class="hljs-comment">//判断下一个数是否能插入第0个子集</span><br>            <span class="hljs-comment">//回溯到不插入的情况，把子集个数减1，再把当前元素标记为不在此子集中</span><br>            -- a[level][<span class="hljs-number">0</span>];                 <br>            h[level][-- ans] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">dfs</span>(level + <span class="hljs-number">1</span>);                 <span class="hljs-comment">//判断这个数是否能插入下一个子集</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; --best &lt;&lt; endl;                 <span class="hljs-comment">//记录的是最优值加一，这里减去一并输出</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= e[i][<span class="hljs-number">0</span>]; j ++)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, e[i][j]);     <span class="hljs-comment">//输出最优解</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/4777/">无和集问题 - AcWing</a></p>
<h3 id="5-时间复杂度-1"><a href="#5-时间复杂度-1" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，假设其位于第i层，则时间消耗为$O(i)$，对于非叶子节点，其时间消耗为$O(1)$,本题时间消耗还与树的层数有关，而层数又是要求的。。。，需要一些推导来得到一个上界吧~</p>
<h1 id="5-7-n色方柱问题"><a href="#5-7-n色方柱问题" class="headerlink" title="5-7 n色方柱问题"></a>5-7 n色方柱问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104113608782.png" srcset="/img/loading.gif" lazyload alt="image-20230104113608782" style="zoom:67%;"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104113717884.png" srcset="/img/loading.gif" lazyload alt="image-20230104113717884" style="zoom:67%;"></p>
<p>为了提高效率，用图论的知识简化了题目（我没怎么看懂为啥这样简化的），谢谢有被恶心到</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230108094031142.png" srcset="/img/loading.gif" lazyload alt="image-20230108094031142"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230108094127364.png" srcset="/img/loading.gif" lazyload alt="image-20230108094127364"></p>
<p>有点难懂，我觉得不会考。。。，理解一下代码吧</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>input.txt:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span><br><span class="hljs-attribute">RGBY</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> board[MAX][<span class="hljs-number">6</span>];  <span class="hljs-comment">//存储n个立方体各面的颜色</span><br><span class="hljs-type">int</span> solu[MAX][<span class="hljs-number">6</span>];   <span class="hljs-comment">//存储解</span><br><span class="hljs-type">int</span> n;  <span class="hljs-comment">//立方体个数、颜色种数</span><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">//解的个数</span><br><span class="hljs-type">int</span> used[MAX];<br><span class="hljs-type">char</span> color[MAX];<br><br><span class="hljs-comment">//找到一个解后，输出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">int</span> edge[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, k, a, b, c, d;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) <span class="hljs-comment">//2个子图</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;n; j++)<br>            used[j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            j = <span class="hljs-number">0</span>;<br>            d = c = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;n &amp;&amp; used[j]&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//找下一条未用的边</span><br>                j++;<br>            <span class="hljs-keyword">if</span>(j &lt; n)<br>                <span class="hljs-keyword">do</span>&#123;<br>                    a = board[j][edge[i*n+j]*<span class="hljs-number">2</span>];<br>                    b = board[j][edge[i*n+j]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(b == d)  <span class="hljs-comment">//如果上一条边的终点与b相同，说明b为始点，交换，保证a为始点</span><br>                        <span class="hljs-built_in">swap</span>(a, b);  <span class="hljs-comment">//保证有向边的始点对应于前面和左面，终点对应于背面和右面</span><br>                    solu[j][i*<span class="hljs-number">2</span>] = a;<br>                    solu[j][i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] = b;<br>                    used[j] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(c&lt;<span class="hljs-number">0</span>)  <span class="hljs-comment">//开始顶点</span><br>                        c = a;<br>                    d = b;<br>                    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>; k&lt;n; k++)  <span class="hljs-comment">//找下一个立方体</span><br>                        <span class="hljs-keyword">if</span>(used[k]==<span class="hljs-number">0</span> &amp;&amp; (board[k][edge[i*n+k]*<span class="hljs-number">2</span>]==b || board[k][edge[i*n+k]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]==b))<br>                            j = k;<br>                &#125;<span class="hljs-keyword">while</span>(b != c);  <span class="hljs-comment">//找了一圈，回到起点</span><br>        &#125;<span class="hljs-keyword">while</span>(j&lt;n);  <span class="hljs-comment">//所有立方体都找遍</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;n; j++) <span class="hljs-comment">//立方体的顶面和底面的颜色</span><br>    &#123;<br>        k = <span class="hljs-number">3</span> - edge[j] - edge[j+n];<br>        a = board[j][k*<span class="hljs-number">2</span>];<br>        b = board[j][k*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>        solu[j][<span class="hljs-number">4</span>] = a;<br>        solu[j][<span class="hljs-number">5</span>] = b;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">6</span>; j++)<br>            cout &lt;&lt; color[solu[i][j]] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, t, cube;<br>    <span class="hljs-type">bool</span> ok, newg, over;<br>    <span class="hljs-type">int</span> *vert = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];  <span class="hljs-comment">//记录子图中每个顶点的度，应均为2</span><br>    <span class="hljs-type">int</span> *edge = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n*<span class="hljs-number">2</span>];  <span class="hljs-comment">//记录每个立方体中边被选用的条数，每个立方体只有3条边，有两个子图要选用</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        vert[i] = <span class="hljs-number">0</span>;<br>    t = <span class="hljs-number">-1</span>;<br>    newg = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">-2</span>)<br>    &#123;<br>        t++;<br>        cube = t % n;  <span class="hljs-comment">//每个立方体找2次，得到真实的立方体编号，也是子图中边的编号</span><br>        <span class="hljs-keyword">if</span>(newg)  <span class="hljs-comment">//如果没有边被选入子图</span><br>            edge[t] = <span class="hljs-number">-1</span>;<br>        over = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//是否结束，即两个子图构建完成</span><br>        ok = <span class="hljs-literal">false</span>;    <span class="hljs-comment">//标记边是否已用过，两个子图不应有公共边</span><br>        <span class="hljs-keyword">while</span>(!ok &amp;&amp; !over)<br>        &#123;<br>            edge[t]++;  <span class="hljs-comment">//边被选用加入子图，使用次数增加</span><br>            <span class="hljs-keyword">if</span>(edge[t]&gt;<span class="hljs-number">2</span>)  <span class="hljs-comment">//在立方体每对相对面的顶点连一条边，每个立方体只有3条边</span><br>                over = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span><br>                ok = (t&lt;n || edge[t]!=edge[cube]);  <span class="hljs-comment">//是否已用过</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(!over)<br>        &#123;          <span class="hljs-comment">//检测边的两个顶点的度</span><br>            <span class="hljs-keyword">if</span>(++vert[board[cube][edge[t]*<span class="hljs-number">2</span>]] &gt; <span class="hljs-number">2</span>+t/<span class="hljs-number">2</span>*<span class="hljs-number">2</span>) <span class="hljs-comment">//如果是第一个子图，顶点度不能超过2</span><br>                ok = <span class="hljs-literal">false</span>;              <span class="hljs-comment">//如果是第二个子图，加上第一个子图，顶点度不能超过4</span><br>            <span class="hljs-keyword">if</span>(++vert[board[cube][edge[t]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]] &gt; <span class="hljs-number">2</span>+t/<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)<br>                ok = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(t%n == n<span class="hljs-number">-1</span> &amp;&amp; ok)  <span class="hljs-comment">//如果一个或两个子图已构建完成</span><br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>                    <span class="hljs-keyword">if</span>(vert[i] &gt; <span class="hljs-number">2</span>+t/n*<span class="hljs-number">2</span>)<br>                        ok = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(ok)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(t == n*<span class="hljs-number">2</span><span class="hljs-number">-1</span>) <span class="hljs-comment">//找到解</span><br>                &#123;<br>                    ans++;<br>                    <span class="hljs-built_in">out</span>(edge);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    newg = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//取下一条边</span><br>            &#123;<br>                --vert[board[cube][edge[t]*<span class="hljs-number">2</span>]];  <span class="hljs-comment">//边的两个顶点</span><br>                --vert[board[cube][edge[t]*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]];<br>                t--;<br>                newg = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//回溯</span><br>        &#123;<br>            t--;<br>            <span class="hljs-keyword">if</span>(t &gt; <span class="hljs-number">-1</span>)<br>            &#123;<br>                cube = t % n;<br>                --vert[board[cube][edge[t]*<span class="hljs-number">2</span>]];<br>                --vert[board[cube][edge[t]*<span class="hljs-number">2</span>]];<br>            &#125;<br>            t--;<br>            newg = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;输入立方体个数：&quot;</span>;<br>    fin &gt;&gt; n;  cout &lt;&lt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入颜色：&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        fin &gt;&gt; color[i];<br>        cout &lt;&lt; color[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入立方体各面颜色：\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">6</span>; j++)<br>        &#123;<br>            fin &gt;&gt; board[i][j];<br>            cout &lt;&lt; board[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n立方体叠置方案为：\n&quot;</span>;<br>    <span class="hljs-built_in">search</span>();<br>    <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;No Solution！\n&quot;</span>;<br>    cout &lt;&lt; end;<br>    fin.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230104115831309.png" srcset="/img/loading.gif" lazyload alt="image-20230104115831309"></p>
<h1 id="5-8-整数变换问题"><a href="#5-8-整数变换问题" class="headerlink" title="5-8 整数变换问题"></a>5-8 整数变换问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105102915399.png" srcset="/img/loading.gif" lazyload alt="image-20230105102915399" style="zoom:67%;"></p>
<p>这道题是一定能找到的，有点类似于3n+1?，要不然会要求输出<code>no solution</code>的，而且我们也不能简单地通过n和m的大小关系来得到此时需要做的操作。题目的思路大概就是DFS暴力搜索，左子树f变换，右子树g变换，主要问题在于需要限制搜索的层数，因为有些分支是得不到解的</p>
<h3 id="1-解空间和解结构-6"><a href="#1-解空间和解结构-6" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>解空间是一个长度为k的向量，向量的每一项是f或者g，k的大小与输入有关，解结构如下：左子树是进行f变换，右子树是进行g变换。</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105111327567.png" srcset="/img/loading.gif" lazyload alt="image-20230105111327567" style="zoom:67%;"></p>
<h3 id="2-剪枝策略-6"><a href="#2-剪枝策略-6" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>虽然看到一些博客根据n和m的大小剪枝，但是实际上在代码中他们没有这样做，而且这种做法应该是不对的。。。</p>
<p>我觉得这里更加类似于DFS，代码也没体现出什么剪枝的策略，这里的搜索过程有点像是一层一层往下搜索，k控制着层数</p>
<h3 id="3-示例-6"><a href="#3-示例-6" class="headerlink" title="3. 示例"></a>3. 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">7</span> <span class="hljs-number">4</span><br><span class="hljs-number">3</span><br>gfg<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105113429567.png" srcset="/img/loading.gif" lazyload alt="image-20230105113429567" style="zoom:50%;"></p>
<h3 id="4-代码-6"><a href="#4-代码-6" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 25</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x3f3f3f3f</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">//定义k来表示搜索树的深度</span><br><span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//定义一个队列来存放各类操作</span><br>queue&lt;<span class="hljs-type">char</span>&gt; q;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//防止死循环，保证最多只能访问到下一层</span><br>    <span class="hljs-keyword">if</span>(x &gt; k)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//找到返回true</span><br>    <span class="hljs-keyword">if</span>(n == m)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//这里必须用一个temp做临时变量</span><br>    <span class="hljs-comment">//若不用temp做临时变量，回溯的时候n的值发生变化</span><br>    <span class="hljs-comment">//导致结果异常</span><br>    <span class="hljs-type">int</span> temp = n;<br>    <span class="hljs-comment">//左右都做一遍，看看能否到达目的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>            temp = n * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">else</span><br>            temp = n / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">DFS</span>(x+<span class="hljs-number">1</span>, temp))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;f&#x27;</span>);<br>            <span class="hljs-keyword">else</span><br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;g&#x27;</span>);<br>            <span class="hljs-comment">//这里必须要return true </span><br>            <span class="hljs-comment">//因为只需要找到第一个满足条件的那条路径</span><br>            <span class="hljs-comment">//回溯返回的时候把路径上的运算加入队列即可。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果没找到返回false,k++</span><br>    <span class="hljs-comment">//可往更深一层探索</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-comment">//找不到，往更深一层探索！</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>, n))<br>        k++;<br>    cout &lt;&lt; k &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-2"><a href="#5-时间复杂度-2" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>树的层数和输入的数关系比较大，不太好分析。。。，如果树的层数可以得到一个上界的话，可以推导一下最坏情况</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Small___ming/article/details/103218990">https://blog.csdn.net/Small___ming/article/details/103218990</a></p>
<h1 id="5-9-拉丁矩阵问题"><a href="#5-9-拉丁矩阵问题" class="headerlink" title="5-9 拉丁矩阵问题"></a>5-9 拉丁矩阵问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105113714306.png" srcset="/img/loading.gif" lazyload alt="image-20230105113714306" style="zoom:67%;"></p>
<p>可以从左到右从上到下来填充矩阵的每个“格子”，即树的每一层就是考虑每个格子里放什么，这将得到一棵比较大的树，剪枝的策略就是题目所要求的，每行每列都没有相同的形状，若在该格子里放入第i种宝石能满足要求，则将其放入，否则剪去该条分支，对于检查每行每列是否有相同形状，可以采用两个矩阵来记录，这样时间效率会高点</p>
<h3 id="1-解空间和解结构-7"><a href="#1-解空间和解结构-7" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>本题是求可行解的个数，解空间是一个n行m列的矩阵，也可以理解为n*m长度的向量，其中向量的每个元素为1~n，对应的解结构为排列树</p>
<h3 id="2-剪枝策略-7"><a href="#2-剪枝策略-7" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护矩阵row[N][N]，其中row[i][j]=1表示第i行已经使用了形状j，矩阵col[N][N]，其中col[j][i]=1表示第i列使用了形状j，考虑在为矩阵(x,y)位置上元素选择宝石时，若选择宝石i，则需要保证<code>row[x][i]==0&amp;&amp;col[i][y]==0</code>，即不与x行和y列上已有的形状冲突，若不满足该条件，则可剪去该子树</p>
<h3 id="3-示例-7"><a href="#3-示例-7" class="headerlink" title="3. 示例"></a>3. 示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105194002403.png" srcset="/img/loading.gif" lazyload alt="image-20230105194002403"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105194603562.png" srcset="/img/loading.gif" lazyload alt="image-20230105194603562" style="zoom:67%;"></p>
<h3 id="4-代码-7"><a href="#4-代码-7" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10</span><br><span class="hljs-type">int</span> m,n;    <span class="hljs-comment">//分别为行、列</span><br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> row[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//row[i][j]=1表示第i行已经使用了形状j</span><br><span class="hljs-type">int</span> col[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//col[j][i]=1表示第i列已经使用了形状j</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"><span class="hljs-comment">//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1</span></span><br><span class="hljs-function"><span class="hljs-comment">//如第一行就是0 1 2 3 4...</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-type">int</span> x,y;    <span class="hljs-comment">//分别为行、列（坐标）</span><br>    <span class="hljs-keyword">if</span>(t==m*n)<span class="hljs-comment">//如果排完了,说明得到了一种可行解</span><br>    &#123;<br>        count++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//否则继续排列</span><br>    x=t/n;      <span class="hljs-comment">//行坐标</span><br>    y=t%n;      <span class="hljs-comment">//列坐标</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//对每种形状都进行尝试</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(row[x][i]==<span class="hljs-number">0</span>&amp;&amp;col[i][y]==<span class="hljs-number">0</span>)<br>        &#123;<br>           row[x][i]=<span class="hljs-number">1</span>;<br>           col[i][y]=<span class="hljs-number">1</span>;<br>           a[x][y]=i;<br>           <span class="hljs-built_in">backtrack</span>(t+<span class="hljs-number">1</span>);<br>           row[x][i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span><br>           col[i][y]=<span class="hljs-number">0</span>;<br>           a[x][y]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count=%d\n&quot;</span>,count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-3"><a href="#5-时间复杂度-3" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于叶子节点，其时间消耗为$O(1)$，对于非叶子节点其时间消耗为$O(n)$，对于n种宝石，排成n行m列的拉丁矩阵问题，时间消耗为$T=O(n^{mn})$</p>
<h1 id="5-10-排列宝石问题"><a href="#5-10-排列宝石问题" class="headerlink" title="5-10 排列宝石问题"></a>5-10 排列宝石问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114234838.png" srcset="/img/loading.gif" lazyload alt="image-20230105114234838" style="zoom:67%;"></p>
<p>这道题是类似于5-9的(直接在5-9上面改的几行)，说一下思路吧：类似于对待不同宝石类型要求每行每列都不重复，引入数组<code>color_row</code>和数组<code>color_col</code>，其大致结构和含义与<code>row</code>和<code>col</code>类似，用于记录该行或者该列是否已经使用过该种颜色的宝石，还引入<code>used</code>数组用于满足题中的每种宝石n颗且不同色（避免一种宝石的一种颜色使用了多次），其中<code>used[i][j]=1</code>表示类型i的宝石的第j种颜色已用。</p>
<p>与5-9对比，排列树可选的分支大大增加了，不过剪去的分支也比较多，时间复杂度往上蹭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;    <span class="hljs-comment">//分别为行、列</span><br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> row[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//row[i][j]=1表示第i行已经使用了形状j</span><br><span class="hljs-type">int</span> col[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//col[j][i]=1表示第i列已经使用了形状j</span><br><span class="hljs-type">int</span> color_row[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> color_col[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> used[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//used[i][j]=1表示类型i的第j种颜色已用</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"><span class="hljs-comment">//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1</span></span><br><span class="hljs-function"><span class="hljs-comment">//如第一行就是0 1 2 3 4...</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-type">int</span> x,y;    <span class="hljs-comment">//分别为行、列（坐标）</span><br>    <span class="hljs-keyword">if</span>(t==n*n)<span class="hljs-comment">//如果排完了,说明得到了一种可行解</span><br>    &#123;<br>        res++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//否则继续排列</span><br>    x=t/n;      <span class="hljs-comment">//行坐标</span><br>    y=t%n;      <span class="hljs-comment">//列坐标</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//对每种形状都进行尝试</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//j为颜色</span><br>        <span class="hljs-keyword">if</span>(!row[x][i]&amp;&amp;!col[i][y]&amp;&amp;!color_row[x][j]&amp;&amp;!color_col[j][y]&amp;&amp;!used[i][j])<br>        &#123;<br>           row[x][i]=<span class="hljs-number">1</span>;<br>           col[i][y]=<span class="hljs-number">1</span>;<br>           color_row[x][j]=<span class="hljs-number">1</span>;<br>           color_col[j][y]=<span class="hljs-number">1</span>;<br>           used[i][j]=<span class="hljs-number">1</span>;<br>           <span class="hljs-built_in">backtrack</span>(t+<span class="hljs-number">1</span>);<br>           row[x][i]=<span class="hljs-number">0</span>;<br>           col[i][y]=<span class="hljs-number">0</span>;<br>           color_row[x][j]=<span class="hljs-number">0</span>;<br>           color_col[j][y]=<span class="hljs-number">0</span>;<br>           used[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;res=%d\n&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-11-重复拉丁矩阵问题"><a href="#5-11-重复拉丁矩阵问题" class="headerlink" title="5-11 重复拉丁矩阵问题"></a>5-11 重复拉丁矩阵问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114335314.png" srcset="/img/loading.gif" lazyload alt="image-20230105114335314" style="zoom: 80%;"></p>
<p>这题是类似于5-9的，我的代码一直没AC，参考了下答案的，思路是：第一行按照题意，由于对每行每种宝石数量的限制，且要求第一行最小字典序，所以是固定的，无需回溯，故从第二行开始进行搜索。答案遵照教材的排列树的写法，先初始化矩阵，然后再做swap操作，矩阵初始化情况如虚线上矩阵(示例为例)，在搜索的时候，只需要考虑每列宝石要求即可（因为初始化的原因，不需要考虑每行了），但是很奇怪的是，代码没有考虑第一列的情况了，即认为第一列也是固定的，但是我觉得不太对，比如虚线下面的一种也是可以的。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">省略第0行、第0列<br>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 3 </span>3<br>1 &lt;1&gt;<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 3 </span>3 3<br>2<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 3 </span>3<br>2<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 3 </span>3<br>----------<span class="language-yaml"><span class="hljs-meta">---</span></span><br><span class="language-yaml"><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> </span><br><span class="language-yaml"><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> </span><br><span class="language-yaml"><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> </span><br><span class="language-yaml"><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> </span><br></code></pre></td></tr></table></figure>
<p>input:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> times[MAX];  <span class="hljs-comment">//每种宝石的重复次数</span><br><span class="hljs-type">int</span> id[MAX];  <span class="hljs-comment">//每个宝石的价值序号</span><br><span class="hljs-type">int</span> board[MAX][MAX];  <span class="hljs-comment">//宝石矩阵</span><br><br><span class="hljs-comment">//考察当前列宝石数是否多于应出现的次数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = board[r][s];<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(s &gt; c)<br>        <span class="hljs-keyword">for</span>(i=c; i&lt;s; i++)<br>            <span class="hljs-keyword">if</span>(board[r][i] == k) <span class="hljs-comment">//如果已经试过相同类型的宝石，这次就不再试了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;r; i++)  <span class="hljs-comment">//考察当前列宝石数是否多于应出现的次数</span><br>        <span class="hljs-keyword">if</span>(board[i][c] == k)<br>            count++;<br>    <span class="hljs-keyword">if</span>(count &gt;= times[k]) <span class="hljs-comment">//times[k]表示种类为k的宝石应出现的次数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">double</span> num = <span class="hljs-number">0</span>;  <span class="hljs-comment">//不同的宝石排列方案数</span><br><span class="hljs-comment">//从上到下，从左到右递归搜索，即先行后列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=c; i&lt;=n; i++)  <span class="hljs-comment">//列</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ok</span>(r, c, i))<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(board[r][c], board[r][i]);<br>            <span class="hljs-keyword">if</span>(c == n)  <span class="hljs-comment">//如果列考察完毕</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(r == m) <span class="hljs-comment">//如果行考察完毕</span><br>                &#123;<br>                    num += <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-built_in">backtrack</span>(r+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//考察下一行</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">backtrack</span>(r, c+<span class="hljs-number">1</span>); <span class="hljs-comment">//考察下一列</span><br>            <span class="hljs-built_in">swap</span>(board[r][c], board[r][i]);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入行数m：&quot;</span>;<br>    fin &gt;&gt; m;  cout &lt;&lt; m;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入列数n：&quot;</span>;<br>    fin &gt;&gt; n;  cout &lt;&lt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入宝石价值种数：&quot;</span>;<br>    fin &gt;&gt; k;  cout &lt;&lt; k &lt;&lt; endl;<br>    <span class="hljs-type">int</span> i, temp;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=k; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;输入第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;种宝石在每行每列出现的最多次数：&quot;</span>;<br>        fin &gt;&gt; times[i];<br>        cout &lt;&lt; times[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>        temp = times[i];<br>        <span class="hljs-keyword">while</span>(temp&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            id[t++] = i;<br>            temp--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;=m; i++)  <span class="hljs-comment">//初始化为单位矩阵</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br>            board[i][j] = id[j];<br>    <span class="hljs-comment">//第一行已经排列好了,无需再改变了</span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    由于初始化后的单位矩阵的第一列都是1，为使矩阵的第一列同时满足一下两个条件： </span><br><span class="hljs-comment">    同一种宝石数都不超过规定的数量，第1列从上到下的宝石按宝石的价值最小字典序从小到大排列 </span><br><span class="hljs-comment">    将第i行的第一个宝石与它同行的第i个宝石交换位置</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)<br>        <span class="hljs-built_in">swap</span>(board[i][<span class="hljs-number">1</span>],board[i][i]);<br>    <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n不同的宝石排列方案数为：&quot;</span> &lt;&lt; num;<br>    cout &lt;&lt; endl &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面是我的代码，在5-9基础上改的，输出的文件out.txt是所有的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> m,n,k;    <span class="hljs-comment">//分别为行、列</span><br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> row[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//row[i][j]=1表示第i行已经使用了形状j</span><br><span class="hljs-type">int</span> col[N][N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//col[j][i]=1表示第i列已经使用了形状j</span><br><span class="hljs-type">int</span> maxtime[N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> t,ofstream&amp;out)</span></span><br><span class="hljs-function"><span class="hljs-comment">//t表示正在填充的矩阵的一个小格子,格子范围为0~m*n-1</span></span><br><span class="hljs-function"><span class="hljs-comment">//如第一行就是0 1 2 3 4...</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x,y;    <span class="hljs-comment">//分别为行、列（坐标）</span><br>    <span class="hljs-keyword">if</span>(t==m*n)<span class="hljs-comment">//如果排完了,说明得到了一种可行解</span><br>    &#123;<br>        res++;<br>        out&lt;&lt;<span class="hljs-string">&quot;---&quot;</span>&lt;&lt;res&lt;&lt;endl;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                out&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            out&lt;&lt;endl;<br>        &#125;<br>        out&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//否则继续排列</span><br>    x=t/n;      <span class="hljs-comment">//行坐标</span><br>    y=t%n;      <span class="hljs-comment">//列坐标</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)<span class="hljs-comment">//对每种形状都进行尝试</span><br>    &#123;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y&gt;<span class="hljs-number">0</span>&amp;&amp;i&lt;a[x][y<span class="hljs-number">-1</span>]) flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>&amp;&amp;x&gt;<span class="hljs-number">0</span>&amp;&amp;i&lt;a[x<span class="hljs-number">-1</span>][y]) flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(flag&amp;&amp;row[x][i]&lt;maxtime[i]&amp;&amp;col[i][y]&lt;maxtime[i])<br>        &#123;<br>           <span class="hljs-comment">//cout&lt;&lt;maxtime[i]&lt;&lt;&quot;: &quot;&lt;&lt;row[x][i]&lt;&lt;&quot;,&quot;&lt;&lt;col[i][y]&lt;&lt;&quot;| &quot;&lt;&lt;res&lt;&lt;endl;</span><br>           row[x][i]++;<br>           col[i][y]++;<br>           a[x][y]=i;<br>           <span class="hljs-built_in">backtrack</span>(t+<span class="hljs-number">1</span>,out);<br>           row[x][i]--;<span class="hljs-comment">//回溯</span><br>           col[i][y]--;<br>           a[x][y]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ofstream out;<br>    out.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;out.txt&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;maxtime[i]);<br>    <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">0</span>,out);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;res=%d\n&quot;</span>,res);<br>    out.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-12-罗密欧与朱丽叶的迷宫问题"><a href="#5-12-罗密欧与朱丽叶的迷宫问题" class="headerlink" title="5-12 罗密欧与朱丽叶的迷宫问题"></a>5-12 罗密欧与朱丽叶的迷宫问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115004711.png" srcset="/img/loading.gif" lazyload alt="image-20230105115004711"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114937912.png" srcset="/img/loading.gif" lazyload alt="image-20230105114937912" style="zoom:67%;"></p>
<p>从罗密欧的位置开始，每次都可以走八个方向，用数字记录方向，若下一次走的方向与直接的不同则记转向次数加一，在考虑进入八个方向的下一位置前，需要考虑该位置是否越界，是否是封闭位置，是否已经走过，且是否走入后当前转向次数大于当前最优解此时，以此作为剪枝策略，当遍历完所有的位置后，若到达了朱丽叶的位置，则考虑更新当前最优解或者是增加最优解的次数</p>
<h3 id="1-解空间和解结构-8"><a href="#1-解空间和解结构-8" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n行m列，封闭房间数为k的迷宫，迷宫问题的解空间为1~n*m-k的全排列，表示某个房间第几次到达，解结构为排列树</p>
<h3 id="2-剪枝策略-8"><a href="#2-剪枝策略-8" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>约束函数：在尝试走入下一位置前，检查该位置是否合法，即是否数组越界，是否为封闭房间，是否已经走过，若不合法，则剪去该子树</p>
<p>限界函数：维护变量curr_rotation表示当前转向次数，min_rotation表示当前最优解的转向次数，若在考虑下一位置时，到达该位置后的转向次数大于最优解的转向次数，则剪去该子树</p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><p>input:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>	<span class="hljs-type">int</span> x, y;<br>&#125;;<br>Point luo;<br>Point ye;<br>Point pos;<br><br><span class="hljs-comment">//	定义八个方向:右,</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span> &#125;; <span class="hljs-comment">//八个方向</span><br><span class="hljs-type">int</span> dy[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span> &#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> board[MAX][MAX];<br><span class="hljs-type">int</span> best[MAX][MAX];<br><span class="hljs-type">int</span> curr_rotation = <span class="hljs-number">0</span>;  <span class="hljs-comment">//转弯次数</span><br><span class="hljs-type">int</span> min_rotation = <span class="hljs-number">100000</span>;   <span class="hljs-comment">//最少转弯次数</span><br><span class="hljs-type">int</span> min_count = <span class="hljs-number">0</span>;  <span class="hljs-comment">//不同的最少转弯道路数</span><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Point_check</span><span class="hljs-params">(Point pos)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (pos.x &gt; <span class="hljs-number">0</span> &amp;&amp; pos.x &lt;= n &amp;&amp; pos.y &gt; <span class="hljs-number">0</span> &amp;&amp; pos.y &lt;= m &amp;&amp; board[pos.x][pos.y] == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//	更新当前最少转弯情况下的路线</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>			best[i][j] = board[i][j];<br>	flag = <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//	回溯算法---&gt;形式参数表示的是traceBack的层数</span><br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">traceBack</span><span class="hljs-params">(<span class="hljs-type">int</span> depth, Point pos, <span class="hljs-type">int</span> di)</span> </span>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		回溯法的终止条件，</span><br><span class="hljs-comment">		当把所有的空房间都遍历一遍</span><br><span class="hljs-comment">		且当前到达的位置是朱丽叶的位置</span><br><span class="hljs-comment">		且当前转弯的次数少于等于历史的次数</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">if</span> (depth == m * n - k &amp;&amp; pos.x == ye.x &amp;&amp; pos.y == ye.y &amp;&amp; curr_rotation &lt;= min_rotation) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			如果当前的curr_count小于min_rotation更新min_rotation、min_count以及路径图</span><br><span class="hljs-comment">		*/</span><br>		<span class="hljs-keyword">if</span> (curr_rotation &lt; min_rotation) &#123;<span class="hljs-comment">//有更少的转向</span><br>			min_rotation = curr_rotation;<br>			min_count = <span class="hljs-number">1</span>;<span class="hljs-comment">//重新计数</span><br><br><br>			<span class="hljs-comment">//	更新路径图</span><br>			<span class="hljs-built_in">upgrade</span>();<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			min_count++;<br>		&#125;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">//	剪枝策略-----当到达这个位置的时候curr_rotation已经大于min_rotation那么进行剪枝</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br><br>			<span class="hljs-comment">//	通过走的方向，计算下一个位置</span><br>			Point next_pos;<br>			next_pos.x = pos.x + dx[i];<br>			next_pos.y = pos.y + dy[i];<br><br>			<span class="hljs-comment">//	每次走一步需要判断你下一个地点的位置是否合法</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Point_check</span>(next_pos)) &#123;<br>				board[next_pos.x][next_pos.y] = depth + <span class="hljs-number">1</span>;<br><br>				<span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">1</span> &amp;&amp; di != i)<br>					curr_rotation++;<br><br>				<span class="hljs-keyword">if</span> (curr_rotation &lt;= min_rotation)<br>					<span class="hljs-built_in">traceBack</span>(depth + <span class="hljs-number">1</span>, next_pos, i);<br><br>				<span class="hljs-comment">//	进行回溯</span><br>				board[next_pos.x][next_pos.y] = <span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">1</span> &amp;&amp; di != i)<br>					curr_rotation--;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-comment">//	迷宫的初始化</span><br>	<span class="hljs-built_in">memset</span>(board, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(board));<br><br>	<span class="hljs-built_in">memset</span>(best,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(board));<br><br><br>	<span class="hljs-comment">//	文件的输入</span><br>	<span class="hljs-function">ifstream <span class="hljs-title">datain</span><span class="hljs-params">(<span class="hljs-string">&quot;input.txt&quot;</span>)</span></span>;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;输入迷宫的宽度：&quot;</span>; datain &gt;&gt; n; cout &lt;&lt; n&lt;&lt;endl;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;\n输入迷宫的长度：&quot;</span>; datain &gt;&gt; m; cout &lt;&lt; m &lt;&lt; endl;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;\n输入封闭房间个数：&quot;</span>; datain &gt;&gt; k; cout &lt;&lt; k &lt;&lt; endl;<br><br>	<span class="hljs-comment">//	封闭房间数据的输入</span><br>	Point forbidden_rooms;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>		datain &gt;&gt; forbidden_rooms.x &gt;&gt; forbidden_rooms.y;<br>		board[forbidden_rooms.x][forbidden_rooms.y] = <span class="hljs-number">-1</span>;<br>	&#125;<br><br>	<span class="hljs-comment">//	输入罗密欧和朱丽叶的位置信息</span><br>	datain &gt;&gt; luo.x &gt;&gt; luo.y;<br>	cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;罗密欧位置坐标：[&quot;</span> &lt;&lt; luo.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; luo.y &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br><br>	board[luo.x][luo.y] = <span class="hljs-number">1</span>;<span class="hljs-comment">//起始位置</span><br><br>	datain &gt;&gt; ye.x &gt;&gt; ye.y;<br>	cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;朱丽叶位置坐标：[&quot;</span> &lt;&lt; ye.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; ye.y &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br><br>	<span class="hljs-comment">//	回溯算法开始</span><br>	<span class="hljs-built_in">traceBack</span>(<span class="hljs-number">1</span>, luo, <span class="hljs-number">0</span>);<br><br><br>	<span class="hljs-comment">//	把结果输出到txt文件中</span><br>	<span class="hljs-function">ofstream <span class="hljs-title">dataout</span><span class="hljs-params">(<span class="hljs-string">&quot;output_data1.txt&quot;</span>, ios::trunc)</span></span>;<br><br>	<span class="hljs-keyword">if</span> (flag) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;\n最小转弯次数：&quot;</span> &lt;&lt; min_rotation &lt;&lt; endl;<br>		cout &lt;&lt; <span class="hljs-string">&quot;\n最小转弯次数的转弯道路数：&quot;</span> &lt;&lt; min_count &lt;&lt; endl;<br>		cout &lt;&lt; <span class="hljs-string">&quot;行走的路线图：&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>				cout &lt;&lt; best[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>			&#125;<br>			cout &lt;&lt; endl;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>				cout &lt;&lt; board[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>			&#125;<br>			cout &lt;&lt; endl;<br>		&#125;<br>		cout&lt;&lt; <span class="hljs-string">&quot;\nNo Solution!&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-13-工作分配问题"><a href="#5-13-工作分配问题" class="headerlink" title="5-13 工作分配问题"></a>5-13 工作分配问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114617529.png" srcset="/img/loading.gif" lazyload alt="image-20230105114617529" style="zoom:67%;"></p>
<p>由于每个工作仅由一人完成，每个人仅做一个工作，对于示例的输入矩阵，所求即为在每一行取一个数，且保证所取数不在同一列，求他们的和最小值，易知如果用暴力解法，设矩阵的行数为n，则解为n个数的排列组合，其中第i个数表示第i个工作分配给第j个人，则对于上述输入矩阵，可以得到可行解（3,2,1），（2,1,3），……</p>
<h3 id="1-解空间和解结构-9"><a href="#1-解空间和解结构-9" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个工作的工作分配问题，其解空间即为1~n的全排列，解结构为排列树，具体而言树的第i层表示第i个工作的分配，每层的顶点表示该工作分配的人，如红色方框框出的节点即表示第1个工作分配给C1</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091616647.png" srcset="/img/loading.gif" lazyload alt="image-20230106091616647" style="zoom: 67%;"></p>
<h3 id="2-剪枝策略-9"><a href="#2-剪枝策略-9" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>在搜索的过程中记录当前费用cv和最优费用bestv,若cv大于等于bestv，则无需再遍历该节点的子树（因为向下搜索的过程费用一定是单调递增的）</p>
<h3 id="3-示例-8"><a href="#3-示例-8" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>分成两幅图来画了，实际上是一幅图</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091745691.png" srcset="/img/loading.gif" lazyload alt="image-20230106091745691" style="zoom:50%;"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106091753460.png" srcset="/img/loading.gif" lazyload alt="image-20230106091753460" style="zoom:50%;"></p>
<h3 id="4-代码-8"><a href="#4-代码-8" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">int</span> Min=INT_MAX;<br><span class="hljs-type">int</span> arr[N][N];<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> state[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//从第t层开始搜索</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t&gt;=num) <span class="hljs-comment">//已经到达叶子节点，继续判断是否找到了最小总费用</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(Min&gt;sum)<span class="hljs-comment">//若当前费用小于最优费用</span><br>        &#123;<br>            Min=sum;<span class="hljs-comment">//更新最优费用</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<span class="hljs-comment">//搜索过程:将作业t进行分配</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!state[i])<span class="hljs-comment">//若第i个人当前无作业</span><br>        &#123;<br>            state[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">//将任务t分配给第i个人</span><br>            sum+=arr[t][i];<span class="hljs-comment">//更新当前费用</span><br>            <span class="hljs-keyword">if</span>(sum&lt;Min) <span class="hljs-built_in">dfs</span>(t+<span class="hljs-number">1</span>);<span class="hljs-comment">//若当前费用小于最优费用,则继续向下搜索</span><br>            state[i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//回溯,恢复原状态</span><br>            sum-=arr[t][i];<span class="hljs-comment">//将当前费用恢复</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ifstream in;<br>    ofstream out;<br>    in.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br>    out.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>    in&gt;&gt;num;<br>    Min=INT_MAX;<br>    sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)<br>        &#123;<br>            in&gt;&gt;arr[i][j];<br>        &#125;<br>        state[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-string">&quot;最小费用为：&quot;</span>&lt;&lt;Min&lt;&lt;endl;<br>    out&lt;&lt;<span class="hljs-string">&quot;最小费用为：&quot;</span>&lt;&lt;Min&lt;&lt;endl;<br>    in.<span class="hljs-built_in">close</span>();<br>    out.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-4"><a href="#5-时间复杂度-4" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，其搜索所需时间为$O(n)$，对于叶子节点，其搜索所需时间为$O(1)$，故对于n个工作的工作分配问题，其时间消耗$T=n<em>(n+n</em>n-1+…+n!)+n!=O(n!*n)$</p>
<h1 id="5-14-布线问题"><a href="#5-14-布线问题" class="headerlink" title="5-14 布线问题"></a>5-14 布线问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105114815154.png" srcset="/img/loading.gif" lazyload alt="image-20230105114815154" style="zoom:67%;"></p>
<p>经典排列树，然后剪枝策略可以维护一个当前最优解的成本，若当前成本大于等于该变量，则剪去该分支。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<h3 id="1-解空间和解结构-10"><a href="#1-解空间和解结构-10" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个元件的布线问题，其解空间为1~n的全排列，解结构为排列树</p>
<h3 id="2-剪枝策略-10"><a href="#2-剪枝策略-10" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护当前最优解的成本<code>bestv</code>和当前费用<code>cv</code>，在考虑线路板t位置上是否放置元件i时，若当前费用加上放置元件i所带来的成本小于当前最优解的成本，则可继续搜索，否则剪去该分支</p>
<h3 id="3-示例-9"><a href="#3-示例-9" class="headerlink" title="3. 示例"></a>3. 示例</h3><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106111415596.png" srcset="/img/loading.gif" lazyload alt="image-20230106111415596" style="zoom: 50%;"></p>
<h3 id="4-代码-9"><a href="#4-代码-9" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">25</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> conn[N][N];<br><span class="hljs-type">int</span> bestx[N];<br><span class="hljs-type">int</span> bestv=INT_MAX;<br><span class="hljs-type">int</span> cv;<br><span class="hljs-type">int</span> cx[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">currentvalue</span><span class="hljs-params">(<span class="hljs-type">int</span> cx[],<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//计算cx第t位带来的成本</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)<span class="hljs-comment">//t是从0开始的</span><br>    &#123;<br>        res=res+conn[cx[i]][cx[t]]*(t-i);<span class="hljs-comment">//cx从0开始</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t==n)<span class="hljs-comment">//到达叶子节点</span><br>    &#123;<br>      <span class="hljs-keyword">if</span>(cv&lt;bestv)<br>      &#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>          &#123;<br>              bestx[i]=cx[i];<br>          &#125;<br>          bestv=cv;<br>      &#125;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t;i&lt;n;i++)<span class="hljs-comment">//cx从0开始</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(cx[t],cx[i]);<br>        <span class="hljs-type">int</span> value=<span class="hljs-built_in">currentvalue</span>(cx,t);<span class="hljs-comment">//计算t这一位带来的成本</span><br>        <span class="hljs-keyword">if</span>(value+cv&lt;bestv)<span class="hljs-comment">//满足限界条件</span><br>        &#123;<br>            cv+=value;<br>            <span class="hljs-built_in">traceback</span>(t+<span class="hljs-number">1</span>);<br>            cv-=value;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(cx[t],cx[i]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            cin&gt;&gt;conn[i][j];<span class="hljs-comment">//构造领接矩阵</span><br>            conn[j][i]=conn[i][j];<span class="hljs-comment">//补全另一半</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cx[i]=i+<span class="hljs-number">1</span>;<span class="hljs-comment">//当前解,先初始化为123...</span><br>    <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>);<br>    cout&lt;&lt;bestv&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        cout&lt;&lt;bestx[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-时间复杂度-5"><a href="#5-时间复杂度-5" class="headerlink" title="5. 时间复杂度"></a>5. 时间复杂度</h3><p>考虑最坏情况，对于n个元件的布线问题，对于非叶子节点，其消耗的时间与其层数t有关，为$O(n-t)$,对于叶子节点，其消耗的时间为$O(n)$，故该问题时间消耗为:$T=n<em>n+n</em>(n-1)<em>(n-1)+n</em>(n-1)<em>(n-2)</em>(n-2)+…+n!+n!<em>n=O(n!</em>n)$</p>
<h1 id="5-15-最佳调度问题"><a href="#5-15-最佳调度问题" class="headerlink" title="5-15 最佳调度问题"></a>5-15 最佳调度问题</h1><h3 id><a href="#" class="headerlink" title></a><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115631677.png" srcset="/img/loading.gif" lazyload alt="image-20230105115631677" style="zoom:67%;"></h3><p>可以一一为每个任务分配工作，每个任务都可以尝试分配给每台机器，从而对排列树进行搜索。用一个数组存储每台机器已经分配的任务的总耗时，搜索到可行解后这个数组中的最大值即为当前解所需时间，在剪枝的过程中，将更新后该数组的值（即表示选择分配给该机器）与当前最优解的耗时比较，若小于则可继续搜索。</p>
<h3 id="1-解空间和解结构-11"><a href="#1-解空间和解结构-11" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个任务k台机器的最佳调度问题，其解空间为长度为n的向量，向量的每一项为1~k，解结构为排列树</p>
<h3 id="2-剪枝策略-11"><a href="#2-剪枝策略-11" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>按照题意，要求完成全部任务的时间最早，故维护变量<code>mintime</code>表示当前最优解的完成时间，数组<code>ans</code>存储每台机器完成当前任务后的时间，在任务分配过程中，尝试将任务i分配给机器j，若<code>t[i]+ans[j]&gt;=mintime</code>，则将该分支剪去，无需再搜索</p>
<h3 id="3-代码-1"><a href="#3-代码-1" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">14</span> <span class="hljs-number">4</span> <span class="hljs-number">16</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k,t[<span class="hljs-number">99</span>],ans[<span class="hljs-number">99</span>],min_time=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">//ans[i]表示第i个机器运行完其上任务后的时间</span><br><span class="hljs-comment">//t[i]表示第i个任务需要的时间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(level==n)<br>	&#123;<br>		<span class="hljs-type">int</span> tmp=*<span class="hljs-built_in">max_element</span>(ans,ans+n);<span class="hljs-comment">//max_element找数组的最大值</span><br>		<span class="hljs-keyword">if</span>(tmp&lt;min_time) min_time=tmp;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<span class="hljs-comment">//尝试分配给第i台机器</span><br>	&#123;<br>		ans[i]+=t[level];<br>		<span class="hljs-keyword">if</span>(ans[i]&lt;min_time) <span class="hljs-built_in">dfs</span>(level+<span class="hljs-number">1</span>);<br>		ans[i]-=t[level];<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;k;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>	cin&gt;&gt;t[i];<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>	cout&lt;&lt;min_time&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，其时间消耗为$O(k)$，对于叶子节点，其时间消耗为$O(n)$，故对于n个任务k台机器的最佳调度问题，其时间消耗为$T=k<em>(k+k^2+…+k^{n-1})+n</em>k^n=O(n*k^n)$</p>
<h1 id="5-16-无优先级运算问题"><a href="#5-16-无优先级运算问题" class="headerlink" title="5-16 无优先级运算问题"></a>5-16 无优先级运算问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115723106.png" srcset="/img/loading.gif" lazyload alt="image-20230105115723106" style="zoom:67%;"></p>
<p>有点类似于整数变换问题，这里也是不知道树的层数，可以从1个数，2个数，…,n个数逐步增加树的层数，在选择数的时候，只能使用未选过的数，以此作为剪枝策略（可以用过数组记录某个数是否选过），使用数组记录该数右侧的运算符，每种符号的选择均作为分支向下搜索，当到达叶子节点时，检查当前运算结果是否为m，若为m，则不继续搜索，程序结束</p>
<h3 id="1-解空间和解结构-12"><a href="#1-解空间和解结构-12" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个正整数的无优先级运算问题，其解空间为长度为2k-1(k从1到n)的向量，该向量的每一个奇数项为1~n的数且相互之间不重复，偶数项为1、2、3、4，分别表示<code>+,-,*,\</code>，解的结构为排列树，具体而言如下所示：</p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106212553925.png" srcset="/img/loading.gif" lazyload alt="image-20230106212553925" style="zoom:50%;"></p>
<h3 id="2-剪枝策略-12"><a href="#2-剪枝策略-12" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护数组<code>flag</code>表示n个数是否使用，<code>flag[i]=1</code>表示第i个数已经使用，当给第dep位数选择数时，若该数已经使用过，则无法选择，剪去该分支</p>
<h3 id="3-代码-2"><a href="#3-代码-2" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">25</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<span class="hljs-comment">//存储题目所给n个数</span><br><span class="hljs-type">int</span> num[N];<span class="hljs-comment">//存储当前解</span><br><span class="hljs-type">int</span> oper[N];<span class="hljs-comment">//num[i] oper[i] num[i+1]</span><br><span class="hljs-type">int</span> flag[N];<span class="hljs-comment">//存储i个数的状态，是否使用</span><br><span class="hljs-type">int</span> k;<span class="hljs-comment">//表示使用的数的个数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">found</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//判断是否找到解</span><br>    <span class="hljs-type">int</span> x=num[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-keyword">switch</span>(oper[i])&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:x+=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:x-=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:x*=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:x/=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (x==m);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span><span class="hljs-comment">//考虑第dep个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep&gt;k)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//第dep个数尝试选择数i</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(flag[i]==<span class="hljs-number">0</span>)<br>        &#123;<br>            num[dep]=a[i];<br>            flag[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<span class="hljs-comment">//选择该数右边的符号</span><br>            &#123;<br>                oper[dep]=j;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(dep+<span class="hljs-number">1</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            flag[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span><span class="hljs-comment">//输出函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        cout&lt;&lt;num[i];<br>        <span class="hljs-keyword">switch</span>(oper[i])&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:cout&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:cout&lt;&lt;<span class="hljs-string">&quot;*&quot;</span>;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:cout&lt;&lt;<span class="hljs-string">&quot;/&quot;</span>;<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;num[k];<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>        flag[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>))<br>        &#123;<br>            cout&lt;&lt;k&lt;&lt;endl;<br>            <span class="hljs-built_in">out</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;No Solution!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-时间复杂度-1"><a href="#4-时间复杂度-1" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，需要n个数，每个非叶子节点的时间消耗为$O(n)$，每个叶子节点的时间消耗为$O(n)$，此时时间消耗为$T=n(1+n+4<em>n+4</em>n^2+4^2<em>n^2+…+4^{n-1}</em>n^{n})=O(n^n<em>n</em>4^{n-1})$，真的很大。。。</p>
<h1 id="5-17-世界名画陈列馆问题"><a href="#5-17-世界名画陈列馆问题" class="headerlink" title="5-17 世界名画陈列馆问题"></a>5-17 世界名画陈列馆问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115824426.png" srcset="/img/loading.gif" lazyload alt="image-20230105115824426" style="zoom:67%;"></p>
<p>input:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>这题的思路参考了书的答案，他的剪枝策略有点复杂</p>
<h3 id="1-解空间和解结构-13"><a href="#1-解空间和解结构-13" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>解空间为长度为n*m的向量，向量的每一项为0或者1，表示是否放置警卫，解结构为子集树</p>
<h3 id="2-剪枝策略-13"><a href="#2-剪枝策略-13" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><ol>
<li>可以证明,当前访问的格点(i,j)已被监视时,放置在(i,j)的情况一定不会比放置在(i+1,j+1)的情况好.当(i+1,j+1)不在网格中时,(i+1,j)和(i,j+1)同理.所以,如果(i,j)已被监视,则不需要在此处放置机器人,直接跳过即可.（update,证明：因为是从上到下从左到右使得格子进入监视状态，当前正在检查访问(i,j)。说明在这之前的(i-1,j)和(i,j-1)已被监视。此时如果放在(i,j)处，只会使得(i+1,j)和(i,j+1)进入访问状态。而如果放在(i+1,j+1)处，显然在完成上述目标的情况下可以使更多格子进入访问状态）</li>
<li>当(i,j)未被监视时,若(i,j+1)已被监视,则在(i,j)放置一定不会比在(i+1,j)放置的情况好.所以当且仅当(i,j)在网格右下角或者(I,j+1)未被监视时才考虑放置在(i,j)的情况.</li>
<li>当(i,j)未被监视时,若(i,j+1)和(i,j+2)均被监视,则在(i+1,j)放置一定不会比在(i+1,j)放置的情况好,所以当且仅当(i,j+1)或(i,j+2)未被监视时才考虑放置在(i,j+1)的情况.</li>
<li>当i=n时,不考虑放置在(i+1,j)的情况.</li>
<li>记录已经监视的格点数,(当前最优值减去当前已放置个数)*5如果小于未监视的格点数,则一定达不到比当前最优值更好的情况,剪去.</li>
<li>类似于(5),考虑更紧的情况,并非每个机器人都能独立监视5个格点,至少会有m/4+5的冗余,这个剪枝仅适用于i&lt;n-1的情况,因为最后两行由于最优值和已放置个数非常接近,总是达不到这个值.</li>
</ol>
<blockquote>
<p>大概就是分为下界剪枝法和控制剪枝法两种，下界剪枝法就是计算剩余需要的警卫数，然后加上当前警卫数和当前最优解警卫数比较，控制剪枝法就是一堆已经证明的放置策略，如2、3、4,</p>
</blockquote>
<h3 id="3-代码-3"><a href="#3-代码-3" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> d[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-comment">//d是个辅助用来改变状态的数组,从第1项开始,对应本身,左,上,右,下</span><br><span class="hljs-type">int</span> x[N][N];<span class="hljs-comment">//当前的放置策略</span><br><span class="hljs-type">int</span> y[N][N];<span class="hljs-comment">//是否受监视</span><br><span class="hljs-type">int</span> bestx[N][N];<span class="hljs-comment">//最优放置策略</span><br><span class="hljs-type">int</span> n,m,best,k=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>,t1,t2,more;<br><span class="hljs-comment">//k为当前警卫数量</span><br><span class="hljs-comment">//t为当前受监视的位置的个数</span><br><span class="hljs-type">bool</span> p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//在(i,j)处放置警卫,改变相邻位置的监视情况</span></span><br><span class="hljs-function"></span>&#123;<br>    x[i][j]=<span class="hljs-number">1</span>;<br>    k++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=<span class="hljs-number">5</span>;s++)<br>    &#123;<br>        <span class="hljs-type">int</span> p=i+d[s][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> q=j+d[s][<span class="hljs-number">2</span>];<br>        y[p][q]++;<br>        <span class="hljs-keyword">if</span>(y[p][q]==<span class="hljs-number">1</span>) t++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">noplace</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//用于撤销在(i,j)上放置的警卫</span></span><br><span class="hljs-function"></span>&#123;<br>    x[i][j]=<span class="hljs-number">0</span>;<br>    k--;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=<span class="hljs-number">5</span>;s++)<br>    &#123;<br>        <span class="hljs-type">int</span> p=i+d[s][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> q=j+d[s][<span class="hljs-number">2</span>];<br>        y[p][q]--;<br>        <span class="hljs-keyword">if</span>(y[p][q]==<span class="hljs-number">0</span>) t--;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        j++;<br>        <span class="hljs-keyword">if</span>(j&gt;m)&#123;<br>            i++;<br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(!(y[i][j]==<span class="hljs-number">0</span>||i&gt;n));<br>    <span class="hljs-comment">//若当前坐标未受监视或全部坐标都受到监视跳出循环</span><br>    <span class="hljs-keyword">if</span>(i&gt;n)&#123;<br>        <span class="hljs-keyword">if</span>(k&lt;best)&#123;<br>            best=k;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                &#123;<br>                    bestx[i][j]=x[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k+(t1-t)/<span class="hljs-number">5</span>&gt;=best)<span class="hljs-comment">//利用k和t估计警卫下界,</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>((i&lt;n<span class="hljs-number">-1</span>)&amp;&amp;(k+(t2-t)/<span class="hljs-number">5</span>)&gt;=best)<span class="hljs-comment">//也是利用k和t估计下界</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(i&lt;n)&#123;<span class="hljs-comment">//下侧放警卫</span><br>        <span class="hljs-built_in">place</span>(i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">traceback</span>(i,j);<br>        <span class="hljs-built_in">noplace</span>(i+<span class="hljs-number">1</span>,j);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&lt;m&amp;&amp;(y[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>||y[i][j+<span class="hljs-number">2</span>]==<span class="hljs-number">0</span>))&#123;<br>        <span class="hljs-built_in">place</span>(i,j+<span class="hljs-number">1</span>);<span class="hljs-comment">//在右侧放警卫</span><br>        <span class="hljs-built_in">traceback</span>(i,j);<br>        <span class="hljs-built_in">noplace</span>(i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>((y[i+<span class="hljs-number">1</span>][j]==<span class="hljs-number">0</span>&amp;&amp;y[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">place</span>(i,j);<span class="hljs-comment">//在本身放警卫</span><br>        <span class="hljs-built_in">traceback</span>(i,j);<br>        <span class="hljs-built_in">noplace</span>(i,j);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;best&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            cout&lt;&lt;bestx[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//下界剪枝法的辅助，主要是用来辅助通过t和k估计警卫人数的下界的</span><br>    more=m/<span class="hljs-number">4</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(m%<span class="hljs-number">4</span>==<span class="hljs-number">3</span>)<br>        more++;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m%<span class="hljs-number">4</span>==<span class="hljs-number">2</span>)<br>        more+=<span class="hljs-number">2</span>;<br>    t2=m*n+more+<span class="hljs-number">4</span>;<br>    t1=m*n+<span class="hljs-number">4</span>;<br>	<span class="hljs-comment">//下面就很好看懂了</span><br>    best=INT_MAX;<br>    <span class="hljs-built_in">memset</span>(y,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(y));<br>    <span class="hljs-built_in">memset</span>(x,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(x));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;&amp;m==<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//构造边界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m+<span class="hljs-number">1</span>;i++)<br>    &#123;<br>        y[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        y[n+<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<br>    &#123;<br>        y[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        y[i][m+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">traceback</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">output</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-18-世界名画陈列馆问题（不重复监视）"><a href="#5-18-世界名画陈列馆问题（不重复监视）" class="headerlink" title="5-18 世界名画陈列馆问题（不重复监视）"></a>5-18 世界名画陈列馆问题（不重复监视）</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115900644.png" srcset="/img/loading.gif" lazyload alt="image-20230105115900644" style="zoom: 80%;"></p>
<p>在5-17上改了下，框架没变，去掉了答案那些控制剪枝法的剪枝策略，加上了题目中要求的不重复监视的剪枝策略，且在叶子节点处加上了对整个矩阵检查是否全部监视了，主要加了check函数，checkall函数，改了traceback函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> d[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-comment">//d是个辅助用来改变状态的数组,从第1项开始,对应本身,左,上,右,下</span><br><span class="hljs-type">int</span> x[N][N];<span class="hljs-comment">//当前的放置策略</span><br><span class="hljs-type">int</span> y[N][N];<span class="hljs-comment">//是否受监视</span><br><span class="hljs-type">int</span> bestx[N][N];<span class="hljs-comment">//最优放置策略</span><br><span class="hljs-type">int</span> n,m,best,k=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>,t1,t2,more;<br><span class="hljs-comment">//k为当前警卫数量</span><br><span class="hljs-comment">//t为当前受监视的位置的个数</span><br><span class="hljs-type">bool</span> p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//在(i,j)处放置警卫,改变相邻位置的监视情况</span></span><br><span class="hljs-function"></span>&#123;<br>    x[i][j]=<span class="hljs-number">1</span>;<br>    k++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=<span class="hljs-number">5</span>;s++)<br>    &#123;<br>        <span class="hljs-type">int</span> p=i+d[s][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> q=j+d[s][<span class="hljs-number">2</span>];<br>        y[p][q]++;<br>        <span class="hljs-keyword">if</span>(y[p][q]==<span class="hljs-number">1</span>) t++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//检查(i,j)是否能放置警卫</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=<span class="hljs-number">5</span>;s++)<br>    &#123;<br>        <span class="hljs-type">int</span> p=i+d[s][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> q=j+d[s][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(y[p][q])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkall</span><span class="hljs-params">()</span><span class="hljs-comment">//检查是否全部都有警卫</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!y[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">noplace</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//用于撤销在(i,j)上放置的警卫</span></span><br><span class="hljs-function"></span>&#123;<br>    x[i][j]=<span class="hljs-number">0</span>;<br>    k--;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=<span class="hljs-number">5</span>;s++)<br>    &#123;<br>        <span class="hljs-type">int</span> p=i+d[s][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> q=j+d[s][<span class="hljs-number">2</span>];<br>        y[p][q]--;<br>        <span class="hljs-keyword">if</span>(y[p][q]==<span class="hljs-number">0</span>) t--;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        j++;<br>        <span class="hljs-keyword">if</span>(j&gt;m)&#123;<br>            i++;<br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(!(y[i][j]==<span class="hljs-number">0</span>||i&gt;n));<br>    <span class="hljs-comment">//若当前坐标未受监视或全部坐标都受到监视跳出循环</span><br>    <span class="hljs-keyword">if</span>(i&gt;n)&#123;<br>        <span class="hljs-keyword">if</span>(k&lt;best&amp;&amp;<span class="hljs-built_in">checkall</span>())&#123;<br>            best=k;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                &#123;<br>                    bestx[i][j]=x[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(k+(t1-t)/<span class="hljs-number">5</span>&gt;=best)<span class="hljs-comment">//利用k和t估计警卫下界,</span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>((i&lt;n<span class="hljs-number">-1</span>)&amp;&amp;(k+(t2-t)/<span class="hljs-number">5</span>)&gt;=best)<span class="hljs-comment">//也是利用k和t估计下界</span><br>        <span class="hljs-keyword">return</span>;<br><br>   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i,j))<br>   &#123;<br>       <span class="hljs-built_in">place</span>(i,j);<br>       <span class="hljs-built_in">traceback</span>(i,j);<br>       <span class="hljs-built_in">noplace</span>(i,j);<br>   &#125;<br>   <span class="hljs-built_in">traceback</span>(i,j);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;best&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            cout&lt;&lt;bestx[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    more=m/<span class="hljs-number">4</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(m%<span class="hljs-number">4</span>==<span class="hljs-number">3</span>)<br>        more++;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m%<span class="hljs-number">4</span>==<span class="hljs-number">2</span>)<br>        more+=<span class="hljs-number">2</span>;<br>    t2=m*n+more+<span class="hljs-number">4</span>;<br>    t1=m*n+<span class="hljs-number">4</span>;<br>	<span class="hljs-comment">//下面就很好看懂了</span><br>    best=INT_MAX;<br>    <span class="hljs-built_in">memset</span>(y,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(y));<br>    <span class="hljs-built_in">memset</span>(x,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(x));<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;&amp;m==<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">traceback</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">output</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-19-算m点问题"><a href="#5-19-算m点问题" class="headerlink" title="5-19 算m点问题"></a>5-19 算m点问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105115926418.png" srcset="/img/loading.gif" lazyload alt="image-20230105115926418" style="zoom: 80%;"></p>
<p>类似于5-16，但是这里一定用到了k个整数，所以只需要稍微改改(把k设置为n-1然后改输出)，而且这种计算方式可以看成是无优先级的</p>
<p>示例应该给错了，应该是下面这样：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">125</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">12</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<span class="hljs-comment">//存储题目所给n个数</span><br><span class="hljs-type">int</span> num[N];<span class="hljs-comment">//存储当前解</span><br><span class="hljs-type">int</span> oper[N];<span class="hljs-comment">//num[i] oper[i] num[i+1]</span><br><span class="hljs-type">int</span> flag[N];<span class="hljs-comment">//存储i个数的状态，是否使用</span><br><span class="hljs-type">int</span> k;<span class="hljs-comment">//表示使用的数的个数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">found</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//判断是否找到解</span><br>    <span class="hljs-type">int</span> x=num[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-keyword">switch</span>(oper[i])&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:x+=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:x-=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:x*=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:x/=num[i+<span class="hljs-number">1</span>]; <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (x==m);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span><span class="hljs-comment">//考虑第dep个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep&gt;k)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//第dep个数尝试选择数i</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(flag[i]==<span class="hljs-number">0</span>)<br>        &#123;<br>            num[dep]=a[i];<br>            flag[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)<span class="hljs-comment">//选择该数右边的符号</span><br>            &#123;<br>                oper[dep]=j;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(dep+<span class="hljs-number">1</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            flag[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span><span class="hljs-comment">//输出函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=num[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        cout&lt;&lt;ans;<br>        <span class="hljs-keyword">switch</span>(oper[i])&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:cout&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>;ans+=num[i+<span class="hljs-number">1</span>];<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;ans-=num[i+<span class="hljs-number">1</span>];<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:cout&lt;&lt;<span class="hljs-string">&quot;*&quot;</span>;ans*=num[i+<span class="hljs-number">1</span>];<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:cout&lt;&lt;<span class="hljs-string">&quot;/&quot;</span>;ans/=num[i+<span class="hljs-number">1</span>];<span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout&lt;&lt;num[i+<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>        flag[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    k=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">out</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;No Solution!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106220815943.png" srcset="/img/loading.gif" lazyload alt="image-20230106220815943"></p>
<h1 id="5-20-部落卫队问题"><a href="#5-20-部落卫队问题" class="headerlink" title="5-20 部落卫队问题"></a>5-20 部落卫队问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120010640.png" srcset="/img/loading.gif" lazyload alt="image-20230105120010640"></p>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120024040.png" srcset="/img/loading.gif" lazyload alt="image-20230105120024040"></p>
<p>类似于0-1背包问题，子集树，左子树为1，右子树为0,约束函数就是不能和当前卫队里已有的居民为仇敌，若为仇敌，则剪去左子树。限界函数是当前卫队里的人数加上除去当前考虑的居民的剩余的居民，若数量还是比best小，则剪去右子树</p>
<h3 id="1-解空间和解结构-14"><a href="#1-解空间和解结构-14" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>对于n个居民的部落卫队问题，其解空间为长度为n的向量，向量的每一项为0或者1，解结构为子集树</p>
<h3 id="2-剪枝策略-14"><a href="#2-剪枝策略-14" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>考虑居民t是否加入卫队，加入卫队即进入左子树，否则进入右子树</p>
<p>约束函数：若居民t和1~t-1中已经加入卫队的居民直接有仇视关系，则t不能加入卫队，剪去左子树</p>
<p>限界函数：若居民t不加入卫队，维护变量cv为当前卫队中居民人数，则卫队未来可能的最多人数为<code>cv+n-t</code>，若该值大于n，才搜索右子树，否则剪去右子树</p>
<h3 id="3-代码-4"><a href="#3-代码-4" class="headerlink" title="3. 代码"></a>3. 代码</h3><p>input：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n,m;<span class="hljs-comment">//n个居民,m个关系</span><br><span class="hljs-type">int</span> relation[N][N];<span class="hljs-comment">//居民关系,0表示正常，1表示仇视,从1开始的</span><br><span class="hljs-type">int</span> cbest=<span class="hljs-number">0</span>;<span class="hljs-comment">//最多的卫兵</span><br><span class="hljs-type">int</span> bestx[N];<span class="hljs-comment">//存储最优解</span><br><span class="hljs-type">int</span> cv=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前卫兵人数</span><br><span class="hljs-type">int</span> x[N];<span class="hljs-comment">//当前解,x[i]=1表示第i个居民是卫兵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//第t个居民是否作为卫兵</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t==n)<span class="hljs-comment">//到达叶子节点</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(cv&gt;cbest)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            &#123;<br>                bestx[i]=x[i];<br>                cbest=cv;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<span class="hljs-comment">//判断是否有冲突</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x[i]==<span class="hljs-number">1</span>&amp;&amp;relation[t+<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>        &#123;<br>            flag=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)<span class="hljs-comment">//考虑是否进入左子树</span><br>    &#123;<br>        x[t]=<span class="hljs-number">1</span>;<br>        cv++;<br>        <span class="hljs-built_in">traceback</span>(t+<span class="hljs-number">1</span>);<br>        x[t]=<span class="hljs-number">0</span>;<br>        cv--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cv+n-t&gt;cbest)<span class="hljs-comment">//考虑是否进入右子树</span><br>    &#123;<br>        <span class="hljs-built_in">traceback</span>(t+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> t1,t2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<span class="hljs-comment">//构造领接矩阵</span><br>    &#123;<br>        cin&gt;&gt;t1&gt;&gt;t2;<br>        relation[t1][t2]=<span class="hljs-number">1</span>;<br>        relation[t2][t1]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//从第0个居民开始考虑</span><br>    cout&lt;&lt;cbest&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cout&lt;&lt;bestx[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106230008395.png" srcset="/img/loading.gif" lazyload alt="image-20230106230008395" style="zoom:67%;"></p>
<h3 id="4-时间复杂度-2"><a href="#4-时间复杂度-2" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，搜索所需时间为$O(t+1)$，其中t为当前的层数，对于叶子节点，其搜索所需时间为$O(n)$，故居民数量为n的部落卫队问题的时间复杂度为$O(n*2^n)$</p>
<h1 id="5-21、5-22"><a href="#5-21、5-22" class="headerlink" title="5-21、5-22"></a>5-21、5-22</h1><p>装载问题和0-1背包问题，见书上例题~</p>
<h1 id="5-23-圆排列问题"><a href="#5-23-圆排列问题" class="headerlink" title="5-23 圆排列问题"></a>5-23 圆排列问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230106231319219.png" srcset="/img/loading.gif" lazyload alt="image-20230106231319219" style="zoom: 80%;"></p>
<p>排列树，在选择一个圆的时候，就能计算他带来的长度（需要单独考虑第一个和最后一个的半径带来的长度），维护当前最优解，若当前解小于最优解才继续搜索，看看代码大概就能懂啦（突然发现书上有这道例题，也可以看看书上的）</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h3 id="1-解空间和解结构-15"><a href="#1-解空间和解结构-15" class="headerlink" title="1. 解空间和解结构"></a>1. 解空间和解结构</h3><p>n个圆的圆排列问题的解空间为1~n的全排列，解结构为排列树</p>
<h3 id="2-剪枝策略-15"><a href="#2-剪枝策略-15" class="headerlink" title="2. 剪枝策略"></a>2. 剪枝策略</h3><p>维护变量<code>minlen</code>表示当前最优解的长度，<code>clen</code>表示当前长度，当考虑放置第t个圆时，计算其带来的长度<code>l</code>，若<code>l+clen&gt;=minlen</code>，则剪去该子树</p>
<h3 id="3-代码-5"><a href="#3-代码-5" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> r[N];<br><span class="hljs-type">double</span> minlen=DBL_MAX;<br><span class="hljs-type">double</span> clen=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> x[N];<span class="hljs-comment">//当前的排列</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bring</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> r[x[t]];<span class="hljs-comment">//第一个就是半径</span><br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//加上t和t-1位置上圆心的x之间的距离</span><br>        <span class="hljs-type">double</span> res=<span class="hljs-number">0</span>;<br>        res=<span class="hljs-built_in">sqrt</span>((r[x[t]]+r[x[t<span class="hljs-number">-1</span>]])*(r[x[t]]+r[x[t<span class="hljs-number">-1</span>]])-<span class="hljs-built_in">abs</span>(r[x[t]]-r[x[t<span class="hljs-number">-1</span>]])*<span class="hljs-built_in">abs</span>(r[x[t]]-r[x[t<span class="hljs-number">-1</span>]]));<br>        <span class="hljs-keyword">if</span>(t==n<span class="hljs-number">-1</span>) res+=r[x[t]];<span class="hljs-comment">//最后一个还要加半径</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//考虑放置的第t个圆</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t==n)<span class="hljs-comment">//叶节点，更新min</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(clen&lt;minlen) minlen=clen;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t;i&lt;n;i++)<span class="hljs-comment">//考虑将未使用的圆放在t位置</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(x[t],x[i]);<br>        <span class="hljs-type">double</span> ctmp=clen;<br>        <span class="hljs-keyword">if</span>(clen+<span class="hljs-built_in">bring</span>(t)&lt;minlen)<span class="hljs-comment">//当前长度小于最优解长度</span><br>        &#123;<br>            clen=clen+<span class="hljs-built_in">bring</span>(t);<br>            <span class="hljs-built_in">traceback</span>(t+<span class="hljs-number">1</span>);<br>            clen=ctmp;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(x[t],x[i]);t<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        cin&gt;&gt;r[i];<br>        x[i]=i;<br>    &#125;<br>    <span class="hljs-built_in">traceback</span>(<span class="hljs-number">0</span>);<br>    cout&lt;&lt;minlen;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-时间复杂度-3"><a href="#4-时间复杂度-3" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h3><p>考虑最坏情况，对于非叶子节点，搜索所需时间为$O(n-t)$，t为叶子节点的层数，对于叶子节点，搜索所需时间为$O(1)$，故n个圆的圆排列问题的最坏情况下时间复杂度为$O(n!)$</p>
<h1 id="5-24"><a href="#5-24" class="headerlink" title="5-24"></a>5-24</h1><p>图着色问题，见书上例题~</p>
<h1 id="5-25-最短加法链问题"><a href="#5-25-最短加法链问题" class="headerlink" title="5-25 最短加法链问题"></a>5-25 最短加法链问题</h1><p><img src="/2023/01/02/%E5%9B%9E%E6%BA%AF%E6%B3%95%E9%A2%98%E8%A7%A3/image-20230105120329010.png" srcset="/img/loading.gif" lazyload alt="image-20230105120329010" style="zoom: 80%;"></p>
<p>类似于整数变换那题，也是树的层数未知，所以可以用变量控制层数慢慢加大，可以采用无优先级运算问题的类似框架去解这道题，不同的是这题随着层数的加大分支数也加大了，剪枝策略是当前考虑的项不能大于23，看看代码就差不多~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> n;<span class="hljs-comment">//需要得到的数</span><br><span class="hljs-type">int</span> x[N];<span class="hljs-comment">//加法链数组</span><br><span class="hljs-type">int</span> k;<span class="hljs-comment">//控制层数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traceback</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span><span class="hljs-comment">//考虑加法链的第t项</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(t==k)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x[k<span class="hljs-number">-1</span>]==n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//选择加法链中的两个相加得到第t项</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;t;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x[i]+x[j]&lt;=n)<span class="hljs-comment">//剪枝，该项要小于等于n</span><br>            &#123;<br>                x[t]=x[i]+x[j];<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(t+<span class="hljs-number">1</span>))<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    x[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)<span class="hljs-comment">//最多n层</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">traceback</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//这里得是1,因为如果是0会直接返回false</span><br>        &#123;<br>            cout&lt;&lt;k<span class="hljs-number">-1</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>            &#123;<br>                cout&lt;&lt;x[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>完结撒花🎉~</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>回溯法题解</div>
      <div>https://leungto.github.io/2023/01/02/回溯法题解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>荔枝</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/25/AI%E5%A4%8D%E4%B9%A0/" title="AI复习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">AI复习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/14/algorithm/" title="algorithm">
                        <span class="hidden-mobile">algorithm</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
